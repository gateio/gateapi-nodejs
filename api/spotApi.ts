/**
 * Gate API
 * Welcome to Gate API APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * Contact: support@mail.gate.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-locals */
import { BatchAmendItem } from '../model/batchAmendItem';
import { BatchOrder } from '../model/batchOrder';
import { CancelBatchOrder } from '../model/cancelBatchOrder';
import { CancelOrderResult } from '../model/cancelOrderResult';
import { CountdownCancelAllSpotTask } from '../model/countdownCancelAllSpotTask';
import { Currency } from '../model/currency';
import { CurrencyPair } from '../model/currencyPair';
import { LiquidateOrder } from '../model/liquidateOrder';
import { OpenOrders } from '../model/openOrders';
import { Order } from '../model/order';
import { OrderBook } from '../model/orderBook';
import { OrderCancel } from '../model/orderCancel';
import { OrderPatch } from '../model/orderPatch';
import { SpotAccount } from '../model/spotAccount';
import { SpotAccountBook } from '../model/spotAccountBook';
import { SpotFee } from '../model/spotFee';
import { SpotInsuranceHistory } from '../model/spotInsuranceHistory';
import { SpotPriceTriggeredOrder } from '../model/spotPriceTriggeredOrder';
import { SystemTime } from '../model/systemTime';
import { Ticker } from '../model/ticker';
import { Trade } from '../model/trade';
import { TriggerOrderResponse } from '../model/triggerOrderResponse';
import { TriggerTime } from '../model/triggerTime';
import { ObjectSerializer } from '../model/models';
import { ApiClient } from './apiClient';
import { AxiosRequestConfig, AxiosResponse } from 'axios';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class SpotApi {
    protected client: ApiClient;

    constructor(client?: ApiClient) {
        if (client) {
            this.client = client;
        } else {
            this.client = new ApiClient();
        }
    }

    /**
     * When a currency corresponds to multiple chains, you can query the information of multiple chains through the `chains` field, such as the charging and recharge status, identification, etc. of the chain
     * @summary Query all currency information
     */
    public async listCurrencies(): Promise<{ response: AxiosResponse; body: Array<Currency> }> {
        const localVarPath = this.client.basePath + '/spot/currencies';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Currency>>(config, 'Array<Currency>', authSettings);
    }

    /**
     *
     * @summary Query single currency information
     * @param currency Currency name
     */
    public async getCurrency(currency: string): Promise<{ response: AxiosResponse; body: Currency }> {
        const localVarPath =
            this.client.basePath +
            '/spot/currencies/{currency}'.replace('{' + 'currency' + '}', encodeURIComponent(String(currency)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling getCurrency.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Currency>(config, 'Currency', authSettings);
    }

    /**
     *
     * @summary Query all supported currency pairs
     */
    public async listCurrencyPairs(): Promise<{ response: AxiosResponse; body: Array<CurrencyPair> }> {
        const localVarPath = this.client.basePath + '/spot/currency_pairs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<CurrencyPair>>(config, 'Array<CurrencyPair>', authSettings);
    }

    /**
     *
     * @summary Query single currency pair details
     * @param currencyPair Currency pair
     */
    public async getCurrencyPair(currencyPair: string): Promise<{ response: AxiosResponse; body: CurrencyPair }> {
        const localVarPath =
            this.client.basePath +
            '/spot/currency_pairs/{currency_pair}'.replace(
                '{' + 'currency_pair' + '}',
                encodeURIComponent(String(currencyPair)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling getCurrencyPair.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<CurrencyPair>(config, 'CurrencyPair', authSettings);
    }

    /**
     * If `currency_pair` is specified, only query that currency pair; otherwise return all information
     * @summary Get currency pair ticker information
     * @param opts Optional parameters
     * @param opts.currencyPair Currency pair
     * @param opts.timezone Timezone
     */
    public async listTickers(opts: {
        currencyPair?: string;
        timezone?: 'utc0' | 'utc8' | 'all';
    }): Promise<{ response: AxiosResponse; body: Array<Ticker> }> {
        const localVarPath = this.client.basePath + '/spot/tickers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        if (opts.timezone !== undefined) {
            localVarQueryParameters['timezone'] = ObjectSerializer.serialize(opts.timezone, "'utc0' | 'utc8' | 'all'");
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Ticker>>(config, 'Array<Ticker>', authSettings);
    }

    /**
     * Market depth buy orders are sorted by price from high to low, sell orders are sorted from low to high
     * @summary Get market depth information
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.interval Price precision for depth aggregation, 0 means no aggregation, defaults to 0 if not specified
     * @param opts.limit Number of depth levels
     * @param opts.withId Return order book update ID
     */
    public async listOrderBook(
        currencyPair: string,
        opts: { interval?: string; limit?: number; withId?: boolean },
    ): Promise<{ response: AxiosResponse; body: OrderBook }> {
        const localVarPath = this.client.basePath + '/spot/order_book';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listOrderBook.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(opts.interval, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.withId !== undefined) {
            localVarQueryParameters['with_id'] = ObjectSerializer.serialize(opts.withId, 'boolean');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<OrderBook>(config, 'OrderBook', authSettings);
    }

    /**
     * Supports querying by time range using `from` and `to` parameters or pagination based on `last_id`. By default, queries the last 30 days.  Pagination based on `last_id` is no longer recommended. If `last_id` is specified, the time range query parameters will be ignored.  When using limit&page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) <= 100,000.
     * @summary Query market transaction records
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.limit Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000
     * @param opts.lastId Specify the currency name to query in batches, and support up to 100 pass parameters at a time
     * @param opts.reverse Whether to retrieve data less than &#x60;last_id&#x60;. Default returns records greater than &#x60;last_id&#x60;.  Set to &#x60;true&#x60; to trace back market trade records, &#x60;false&#x60; to get latest trades.  No effect when &#x60;last_id&#x60; is not set.
     * @param opts.from Start timestamp for the query
     * @param opts.to End timestamp for the query, defaults to current time if not specified
     * @param opts.page Page number
     */
    public async listTrades(
        currencyPair: string,
        opts: { limit?: number; lastId?: string; reverse?: boolean; from?: number; to?: number; page?: number },
    ): Promise<{ response: AxiosResponse; body: Array<Trade> }> {
        const localVarPath = this.client.basePath + '/spot/trades';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listTrades.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.lastId !== undefined) {
            localVarQueryParameters['last_id'] = ObjectSerializer.serialize(opts.lastId, 'string');
        }

        if (opts.reverse !== undefined) {
            localVarQueryParameters['reverse'] = ObjectSerializer.serialize(opts.reverse, 'boolean');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Trade>>(config, 'Array<Trade>', authSettings);
    }

    /**
     * Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
     * @summary Market K-line chart
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.limit Maximum number of recent data points to return. &#x60;limit&#x60; conflicts with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected.
     * @param opts.from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified
     * @param opts.to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision
     * @param opts.interval Time interval between data points. Note that &#x60;30d&#x60; represents a calendar month, not aligned to 30 days
     */
    public async listCandlesticks(
        currencyPair: string,
        opts: {
            limit?: number;
            from?: number;
            to?: number;
            interval?: '1s' | '10s' | '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d' | '7d' | '30d';
        },
    ): Promise<{ response: AxiosResponse; body: Array<Array<string>> }> {
        const localVarPath = this.client.basePath + '/spot/candlesticks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listCandlesticks.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(
                opts.interval,
                "'1s' | '10s' | '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d' | '7d' | '30d'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Array<string>>>(config, 'Array<Array<string>>', authSettings);
    }

    /**
     * This API is deprecated. The new fee query API is `/wallet/fee`
     * @summary Query account fee rates
     * @param opts Optional parameters
     * @param opts.currencyPair Specify currency pair to get more accurate fee settings.  This field is optional. Usually fee settings are the same for all currency pairs.
     */
    public async getFee(opts: { currencyPair?: string }): Promise<{ response: AxiosResponse; body: SpotFee }> {
        const localVarPath = this.client.basePath + '/spot/fee';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<SpotFee>(config, 'SpotFee', authSettings);
    }

    /**
     *
     * @summary Batch query account fee rates
     * @param currencyPairs Maximum 50 currency pairs per request
     */
    public async getBatchSpotFee(
        currencyPairs: string,
    ): Promise<{ response: AxiosResponse; body: { [key: string]: SpotFee } }> {
        const localVarPath = this.client.basePath + '/spot/batch_fee';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPairs' is not null or undefined
        if (currencyPairs === null || currencyPairs === undefined) {
            throw new Error('Required parameter currencyPairs was null or undefined when calling getBatchSpotFee.');
        }

        localVarQueryParameters['currency_pairs'] = ObjectSerializer.serialize(currencyPairs, 'string');

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<{ [key: string]: SpotFee }>(config, '{ [key: string]: SpotFee; }', authSettings);
    }

    /**
     *
     * @summary List spot trading accounts
     * @param opts Optional parameters
     * @param opts.currency Query by specified currency name
     */
    public async listSpotAccounts(opts: {
        currency?: string;
    }): Promise<{ response: AxiosResponse; body: Array<SpotAccount> }> {
        const localVarPath = this.client.basePath + '/spot/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(opts.currency, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SpotAccount>>(config, 'Array<SpotAccount>', authSettings);
    }

    /**
     * Record query time range cannot exceed 30 days.  When using limit&page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) <= 100,000.
     * @summary Query spot account transaction history
     * @param opts Optional parameters
     * @param opts.currency Query by specified currency name
     * @param opts.from Start timestamp for the query
     * @param opts.to End timestamp for the query, defaults to current time if not specified
     * @param opts.page Page number
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.type Query by specified account change type. If not specified, all change types will be included.
     * @param opts.code Specify account change code for query. If not specified, all change types are included. This parameter has higher priority than &#x60;type&#x60;
     */
    public async listSpotAccountBook(opts: {
        currency?: string;
        from?: number;
        to?: number;
        page?: number;
        limit?: number;
        type?: string;
        code?: string;
    }): Promise<{ response: AxiosResponse; body: Array<SpotAccountBook> }> {
        const localVarPath = this.client.basePath + '/spot/account_book';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(opts.currency, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(opts.type, 'string');
        }

        if (opts.code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(opts.code, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SpotAccountBook>>(config, 'Array<SpotAccountBook>', authSettings);
    }

    /**
     * Batch order requirements:  1. Custom order field `text` must be specified 2. Up to 4 currency pairs per request, with up to 10 orders per currency pair 3. Spot orders and margin orders cannot be mixed; all `account` fields in the same request must be identical
     * @summary Batch place orders
     * @param order
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async createBatchOrders(
        order: Array<Order>,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: Array<BatchOrder> }> {
        const localVarPath = this.client.basePath + '/spot/batch_orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling createBatchOrders.');
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(order, 'Array<Order>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<BatchOrder>>(config, 'Array<BatchOrder>', authSettings);
    }

    /**
     * Query the current order list of all trading pairs. Please note that the paging parameter controls the number of pending orders in each trading pair. There is no paging control trading pairs. All trading pairs with pending orders will be returned.
     * @summary List all open orders
     * @param opts Optional parameters
     * @param opts.page Page number
     * @param opts.limit Maximum number of records returned in one page in each currency pair
     * @param opts.account Specify query account
     */
    public async listAllOpenOrders(opts: {
        page?: number;
        limit?: number;
        account?: string;
    }): Promise<{ response: AxiosResponse; body: Array<OpenOrders> }> {
        const localVarPath = this.client.basePath + '/spot/open_orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OpenOrders>>(config, 'Array<OpenOrders>', authSettings);
    }

    /**
     * Currently, only cross-margin accounts are supported to place buy orders for disabled currencies. Maximum buy quantity = (unpaid principal and interest - currency balance - the amount of the currency in pending orders) / 0.998
     * @summary Close position when cross-currency is disabled
     * @param liquidateOrder
     */
    public async createCrossLiquidateOrder(
        liquidateOrder: LiquidateOrder,
    ): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath = this.client.basePath + '/spot/cross_liquidate_orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'liquidateOrder' is not null or undefined
        if (liquidateOrder === null || liquidateOrder === undefined) {
            throw new Error(
                'Required parameter liquidateOrder was null or undefined when calling createCrossLiquidateOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(liquidateOrder, 'LiquidateOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * Note that query results default to spot order lists for spot, unified account, and isolated margin accounts.  When `status` is set to `open` (i.e., when querying pending order lists), only `page` and `limit` pagination controls are supported. `limit` can only be set to a maximum of 100. The `side` parameter and time range query parameters `from` and `to` are not supported.  When `status` is set to `finished` (i.e., when querying historical orders), in addition to pagination queries, `from` and `to` time range queries are also supported. Additionally, the `side` parameter can be set to filter one-sided history.  Time range filter parameters are processed according to the order end time.
     * @summary List orders
     * @param currencyPair Query by specified currency pair. Required for open orders, optional for filled orders
     * @param status List orders based on status  &#x60;open&#x60; - order is waiting to be filled &#x60;finished&#x60; - order has been filled or cancelled
     * @param opts Optional parameters
     * @param opts.page Page number
     * @param opts.limit Maximum number of records to be returned. If &#x60;status&#x60; is &#x60;open&#x60;, maximum of &#x60;limit&#x60; is 100
     * @param opts.account Specify query account
     * @param opts.from Start timestamp for the query
     * @param opts.to End timestamp for the query, defaults to current time if not specified
     * @param opts.side Specify all bids or all asks, both included if not specified
     */
    public async listOrders(
        currencyPair: string,
        status: string,
        opts: { page?: number; limit?: number; account?: string; from?: number; to?: number; side?: string },
    ): Promise<{ response: AxiosResponse; body: Array<Order> }> {
        const localVarPath = this.client.basePath + '/spot/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listOrders.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling listOrders.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, 'string');

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.side !== undefined) {
            localVarQueryParameters['side'] = ObjectSerializer.serialize(opts.side, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Order>>(config, 'Array<Order>', authSettings);
    }

    /**
     * Supports spot, margin, leverage, and cross-margin leverage orders. Use different accounts through the `account` field. Default is `spot`, which means using the spot account to place orders. If the user has a `unified` account, the default is to place orders with the unified account.  When using leveraged account trading (i.e., when `account` is set to `margin`), you can set `auto_borrow` to `true`. In case of insufficient account balance, the system will automatically execute `POST /margin/uni/loans` to borrow the insufficient amount. Whether assets obtained after leveraged order execution are automatically used to repay borrowing orders of the isolated margin account depends on the automatic repayment settings of the user\'s isolated margin account. Account automatic repayment settings can be queried and set through `/margin/auto_repay`.  When using unified account trading (i.e., when `account` is set to `unified`), `auto_borrow` can also be enabled to realize automatic borrowing of insufficient amounts. However, unlike the isolated margin account, whether unified account orders are automatically repaid depends on the `auto_repay` setting when placing the order. This setting only applies to the current order, meaning only assets obtained after order execution will be used to repay borrowing orders of the cross-margin account. Unified account ordering currently supports enabling both `auto_borrow` and `auto_repay` simultaneously.  Auto repayment will be triggered when the order ends, i.e., when `status` is `cancelled` or `closed`.  **Order Status**  The order status in pending orders is `open`, which remains `open` until all quantity is filled. If fully filled, the order ends and status becomes `closed`. If the order is cancelled before all transactions are completed, regardless of partial fills, the status will become `cancelled`.  **Iceberg Orders**  `iceberg` is used to set the displayed quantity of iceberg orders and does not support complete hiding. Note that hidden portions are charged according to the taker\'s fee rate.  **Self-Trade Prevention**  Set `stp_act` to determine the self-trade prevention strategy to use
     * @summary Create an order
     * @param order
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async createOrder(
        order: Order,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath = this.client.basePath + '/spot/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling createOrder.');
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(order, 'Order'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * When the `account` parameter is not specified, all pending orders including spot, unified account, and isolated margin will be cancelled. When `currency_pair` is not specified, all trading pair pending orders will be cancelled. You can specify a particular account to cancel all pending orders under that account
     * @summary Cancel all `open` orders in specified currency pair
     * @param opts Optional parameters
     * @param opts.currencyPair Currency pair
     * @param opts.side Specify all bids or all asks, both included if not specified
     * @param opts.account Specify account type  Classic account: All are included if not specified Unified account: Specify &#x60;unified&#x60;
     * @param opts.actionMode Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default)
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async cancelOrders(opts: {
        currencyPair?: string;
        side?: string;
        account?: string;
        actionMode?: string;
        xGateExptime?: string;
    }): Promise<{ response: AxiosResponse; body: Array<OrderCancel> }> {
        const localVarPath = this.client.basePath + '/spot/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        if (opts.side !== undefined) {
            localVarQueryParameters['side'] = ObjectSerializer.serialize(opts.side, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        if (opts.actionMode !== undefined) {
            localVarQueryParameters['action_mode'] = ObjectSerializer.serialize(opts.actionMode, 'string');
        }

        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OrderCancel>>(config, 'Array<OrderCancel>', authSettings);
    }

    /**
     * Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
     * @summary Cancel batch orders by specified ID list
     * @param cancelBatchOrder
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async cancelBatchOrders(
        cancelBatchOrder: Array<CancelBatchOrder>,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: Array<CancelOrderResult> }> {
        const localVarPath = this.client.basePath + '/spot/cancel_batch_orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'cancelBatchOrder' is not null or undefined
        if (cancelBatchOrder === null || cancelBatchOrder === undefined) {
            throw new Error(
                'Required parameter cancelBatchOrder was null or undefined when calling cancelBatchOrders.',
            );
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(cancelBatchOrder, 'Array<CancelBatchOrder>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<CancelOrderResult>>(config, 'Array<CancelOrderResult>', authSettings);
    }

    /**
     * By default, queries orders for spot, unified account, and isolated margin accounts.
     * @summary Query single order details
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user\&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)
     * @param currencyPair Specify the trading pair to query. This field is required when querying pending order records. This field can be omitted when querying filled order records.
     * @param opts Optional parameters
     * @param opts.account Specify query account
     */
    public async getOrder(
        orderId: string,
        currencyPair: string,
        opts: { account?: string },
    ): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath =
            this.client.basePath +
            '/spot/orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrder.');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling getOrder.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * By default, orders for spot, unified accounts and leveraged accounts are revoked.
     * @summary Cancel single order
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user\&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.account Specify query account
     * @param opts.actionMode Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default)
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async cancelOrder(
        orderId: string,
        currencyPair: string,
        opts: { account?: string; actionMode?: string; xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath =
            this.client.basePath +
            '/spot/orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelOrder.');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling cancelOrder.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        if (opts.actionMode !== undefined) {
            localVarQueryParameters['action_mode'] = ObjectSerializer.serialize(opts.actionMode, 'string');
        }

        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * Modify orders in spot, unified account and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation operation.
     * @summary Amend single order
     * @param orderId The order ID returned when the order was successfully created or the custom ID specified by the user\&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)
     * @param orderPatch
     * @param opts Optional parameters
     * @param opts.currencyPair Currency pair
     * @param opts.account Specify query account
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async amendOrder(
        orderId: string,
        orderPatch: OrderPatch,
        opts: { currencyPair?: string; account?: string; xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath =
            this.client.basePath +
            '/spot/orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling amendOrder.');
        }

        // verify required parameter 'orderPatch' is not null or undefined
        if (orderPatch === null || orderPatch === undefined) {
            throw new Error('Required parameter orderPatch was null or undefined when calling amendOrder.');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'PATCH',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(orderPatch, 'OrderPatch'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * By default query of transaction records for spot, unified account and warehouse-by-site leverage accounts.  The history within a specified time range can be queried by specifying `from` or (and) `to`.  - If no time parameters are specified, only data for the last 7 days can be obtained. - If only any parameter of `from` or `to` is specified, only 7-day data from the start (or end) of the specified time is returned. - The range not allowed to exceed 30 days.  The parameters of the time range filter are processed according to the order end time.  The maximum number of pages when searching data using limit&page paging function is 100,0, that is, limit * (page - 1) <= 100,0.
     * @summary Query personal trading records
     * @param opts Optional parameters
     * @param opts.currencyPair Retrieve results with specified currency pair
     * @param opts.limit Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000
     * @param opts.page Page number
     * @param opts.orderId Filter trades with specified order ID. &#x60;currency_pair&#x60; is also required if this field is present
     * @param opts.account Specify query account
     * @param opts.from Start timestamp for the query
     * @param opts.to End timestamp for the query, defaults to current time if not specified
     */
    public async listMyTrades(opts: {
        currencyPair?: string;
        limit?: number;
        page?: number;
        orderId?: string;
        account?: string;
        from?: number;
        to?: number;
    }): Promise<{ response: AxiosResponse; body: Array<Trade> }> {
        const localVarPath = this.client.basePath + '/spot/my_trades';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.orderId !== undefined) {
            localVarQueryParameters['order_id'] = ObjectSerializer.serialize(opts.orderId, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Trade>>(config, 'Array<Trade>', authSettings);
    }

    /**
     *
     * @summary Get server current time
     */
    public async getSystemTime(): Promise<{ response: AxiosResponse; body: SystemTime }> {
        const localVarPath = this.client.basePath + '/spot/time';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<SystemTime>(config, 'SystemTime', authSettings);
    }

    /**
     * Spot order heartbeat detection. If there is no \"cancel existing countdown\" or \"set new countdown\" when the user-set `timeout` time is reached, the related `spot pending orders` will be automatically cancelled. This interface can be called repeatedly to set a new countdown or cancel the countdown. Usage example: Repeat this interface at 30s intervals, setting the countdown `timeout` to `30 (seconds)` each time. If this interface is not called again within 30 seconds, all pending orders on the `market` you specified will be automatically cancelled. If no `market` is specified, all market cancelled. If the `timeout` is set to 0 within 30 seconds, the countdown timer will be terminated and the automatic order cancellation function will be cancelled.
     * @summary Countdown cancel orders
     * @param countdownCancelAllSpotTask
     */
    public async countdownCancelAllSpot(
        countdownCancelAllSpotTask: CountdownCancelAllSpotTask,
    ): Promise<{ response: AxiosResponse; body: TriggerTime }> {
        const localVarPath = this.client.basePath + '/spot/countdown_cancel_all';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'countdownCancelAllSpotTask' is not null or undefined
        if (countdownCancelAllSpotTask === null || countdownCancelAllSpotTask === undefined) {
            throw new Error(
                'Required parameter countdownCancelAllSpotTask was null or undefined when calling countdownCancelAllSpot.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(countdownCancelAllSpotTask, 'CountdownCancelAllSpotTask'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerTime>(config, 'TriggerTime', authSettings);
    }

    /**
     * Modify orders in spot, unified account and isolated margin account by default. Modify uncompleted orders, up to 5 orders can be modified at a time. Request parameters should be passed in array format. If there are order modification failures during the batch modification process, the modification of the next order will continue to be executed, and the execution will return with the corresponding order failure information. The call order of batch modification orders is consistent with the order list order. The return content order of batch modification orders is consistent with the order list order.
     * @summary Batch modification of orders
     * @param batchAmendItem
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async amendBatchOrders(
        batchAmendItem: Array<BatchAmendItem>,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: Array<BatchOrder> }> {
        const localVarPath = this.client.basePath + '/spot/amend_batch_orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'batchAmendItem' is not null or undefined
        if (batchAmendItem === null || batchAmendItem === undefined) {
            throw new Error('Required parameter batchAmendItem was null or undefined when calling amendBatchOrders.');
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(batchAmendItem, 'Array<BatchAmendItem>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<BatchOrder>>(config, 'Array<BatchOrder>', authSettings);
    }

    /**
     *
     * @summary Query spot insurance fund historical data
     * @param business Leverage business, margin - position by position; unified - unified account
     * @param currency Currency
     * @param from Start timestamp in seconds
     * @param to End timestamp in seconds
     * @param opts Optional parameters
     * @param opts.page Page number
     * @param opts.limit The maximum number of items returned in the list, the default value is 30
     */
    public async getSpotInsuranceHistory(
        business: string,
        currency: string,
        from: number,
        to: number,
        opts: { page?: number; limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<SpotInsuranceHistory> }> {
        const localVarPath = this.client.basePath + '/spot/insurance_history';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'business' is not null or undefined
        if (business === null || business === undefined) {
            throw new Error('Required parameter business was null or undefined when calling getSpotInsuranceHistory.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling getSpotInsuranceHistory.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling getSpotInsuranceHistory.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling getSpotInsuranceHistory.');
        }

        opts = opts || {};
        localVarQueryParameters['business'] = ObjectSerializer.serialize(business, 'string');

        localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, 'string');

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        localVarQueryParameters['from'] = ObjectSerializer.serialize(from, 'number');

        localVarQueryParameters['to'] = ObjectSerializer.serialize(to, 'number');

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<SpotInsuranceHistory>>(config, 'Array<SpotInsuranceHistory>', authSettings);
    }

    /**
     *
     * @summary Query running auto order list
     * @param status Query order list based on status
     * @param opts Optional parameters
     * @param opts.market Trading market
     * @param opts.account Trading account type. Unified account must be set to &#x60;unified&#x60;
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listSpotPriceTriggeredOrders(
        status: 'open' | 'finished',
        opts: { market?: string; account?: 'normal' | 'margin' | 'unified'; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<SpotPriceTriggeredOrder> }> {
        const localVarPath = this.client.basePath + '/spot/price_orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error(
                'Required parameter status was null or undefined when calling listSpotPriceTriggeredOrders.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'open' | 'finished'");

        if (opts.market !== undefined) {
            localVarQueryParameters['market'] = ObjectSerializer.serialize(opts.market, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(
                opts.account,
                "'normal' | 'margin' | 'unified'",
            );
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SpotPriceTriggeredOrder>>(
            config,
            'Array<SpotPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Create price-triggered order
     * @param spotPriceTriggeredOrder
     */
    public async createSpotPriceTriggeredOrder(
        spotPriceTriggeredOrder: SpotPriceTriggeredOrder,
    ): Promise<{ response: AxiosResponse; body: TriggerOrderResponse }> {
        const localVarPath = this.client.basePath + '/spot/price_orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'spotPriceTriggeredOrder' is not null or undefined
        if (spotPriceTriggeredOrder === null || spotPriceTriggeredOrder === undefined) {
            throw new Error(
                'Required parameter spotPriceTriggeredOrder was null or undefined when calling createSpotPriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(spotPriceTriggeredOrder, 'SpotPriceTriggeredOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerOrderResponse>(config, 'TriggerOrderResponse', authSettings);
    }

    /**
     *
     * @summary Cancel all auto orders
     * @param opts Optional parameters
     * @param opts.market Trading market
     * @param opts.account Trading account type. Unified account must be set to &#x60;unified&#x60;
     */
    public async cancelSpotPriceTriggeredOrderList(opts: {
        market?: string;
        account?: 'normal' | 'margin' | 'unified';
    }): Promise<{ response: AxiosResponse; body: Array<SpotPriceTriggeredOrder> }> {
        const localVarPath = this.client.basePath + '/spot/price_orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.market !== undefined) {
            localVarQueryParameters['market'] = ObjectSerializer.serialize(opts.market, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(
                opts.account,
                "'normal' | 'margin' | 'unified'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SpotPriceTriggeredOrder>>(
            config,
            'Array<SpotPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Query single auto order details
     * @param orderId ID returned when order is successfully created
     */
    public async getSpotPriceTriggeredOrder(
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: SpotPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/spot/price_orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error(
                'Required parameter orderId was null or undefined when calling getSpotPriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<SpotPriceTriggeredOrder>(config, 'SpotPriceTriggeredOrder', authSettings);
    }

    /**
     *
     * @summary Cancel single auto order
     * @param orderId ID returned when order is successfully created
     */
    public async cancelSpotPriceTriggeredOrder(
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: SpotPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/spot/price_orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error(
                'Required parameter orderId was null or undefined when calling cancelSpotPriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<SpotPriceTriggeredOrder>(config, 'SpotPriceTriggeredOrder', authSettings);
    }
}
