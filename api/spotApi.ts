/**
 * Gate API v4
 * Welcome to Gate.io API  APIv4 provides spot, margin and futures trading operations. There are public APIs to retrieve the real-time market statistics, and private APIs which needs authentication to trade on user\'s behalf.
 *
 * Contact: support@mail.gate.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-locals */
import { BatchAmendItem } from '../model/batchAmendItem';
import { BatchOrder } from '../model/batchOrder';
import { CancelBatchOrder } from '../model/cancelBatchOrder';
import { CancelOrderResult } from '../model/cancelOrderResult';
import { CountdownCancelAllSpotTask } from '../model/countdownCancelAllSpotTask';
import { Currency } from '../model/currency';
import { CurrencyPair } from '../model/currencyPair';
import { LiquidateOrder } from '../model/liquidateOrder';
import { OpenOrders } from '../model/openOrders';
import { Order } from '../model/order';
import { OrderBook } from '../model/orderBook';
import { OrderCancel } from '../model/orderCancel';
import { OrderPatch } from '../model/orderPatch';
import { SpotAccount } from '../model/spotAccount';
import { SpotAccountBook } from '../model/spotAccountBook';
import { SpotFee } from '../model/spotFee';
import { SpotInsuranceHistory } from '../model/spotInsuranceHistory';
import { SpotPriceTriggeredOrder } from '../model/spotPriceTriggeredOrder';
import { SystemTime } from '../model/systemTime';
import { Ticker } from '../model/ticker';
import { Trade } from '../model/trade';
import { TriggerOrderResponse } from '../model/triggerOrderResponse';
import { TriggerTime } from '../model/triggerTime';
import { ObjectSerializer } from '../model/models';
import { ApiClient } from './apiClient';
import { AxiosRequestConfig, AxiosResponse } from 'axios';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class SpotApi {
    protected client: ApiClient;

    constructor(client?: ApiClient) {
        if (client) {
            this.client = client;
        } else {
            this.client = new ApiClient();
        }
    }

    /**
     * Currency has two forms:  1. Only currency name, e.g., BTC, USDT 2. `<currency>_<chain>`, e.g., `HT_ETH`  The latter one occurs when one currency has multiple chains. Currency detail contains a `chain` field whatever the form is. To retrieve all chains of one currency, you can use use all the details which has the name of the currency or name starting with `<currency>_`.
     * @summary List all currencies\' details
     */
    public async listCurrencies(): Promise<{ response: AxiosResponse; body: Array<Currency> }> {
        const localVarPath = this.client.basePath + '/spot/currencies';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Currency>>(config, 'Array<Currency>', authSettings);
    }

    /**
     *
     * @summary Get details of a specific currency
     * @param currency Currency name
     */
    public async getCurrency(currency: string): Promise<{ response: AxiosResponse; body: Currency }> {
        const localVarPath =
            this.client.basePath +
            '/spot/currencies/{currency}'.replace('{' + 'currency' + '}', encodeURIComponent(String(currency)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling getCurrency.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Currency>(config, 'Currency', authSettings);
    }

    /**
     *
     * @summary List all currency pairs supported
     */
    public async listCurrencyPairs(): Promise<{ response: AxiosResponse; body: Array<CurrencyPair> }> {
        const localVarPath = this.client.basePath + '/spot/currency_pairs';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<CurrencyPair>>(config, 'Array<CurrencyPair>', authSettings);
    }

    /**
     *
     * @summary Get details of a specifc currency pair
     * @param currencyPair Currency pair
     */
    public async getCurrencyPair(currencyPair: string): Promise<{ response: AxiosResponse; body: CurrencyPair }> {
        const localVarPath =
            this.client.basePath +
            '/spot/currency_pairs/{currency_pair}'.replace(
                '{' + 'currency_pair' + '}',
                encodeURIComponent(String(currencyPair)),
            );
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling getCurrencyPair.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<CurrencyPair>(config, 'CurrencyPair', authSettings);
    }

    /**
     * Return only related data if `currency_pair` is specified; otherwise return all of them
     * @summary Retrieve ticker information
     * @param opts Optional parameters
     * @param opts.currencyPair Currency pair
     * @param opts.timezone Timezone
     */
    public async listTickers(opts: {
        currencyPair?: string;
        timezone?: 'utc0' | 'utc8' | 'all';
    }): Promise<{ response: AxiosResponse; body: Array<Ticker> }> {
        const localVarPath = this.client.basePath + '/spot/tickers';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        if (opts.timezone !== undefined) {
            localVarQueryParameters['timezone'] = ObjectSerializer.serialize(opts.timezone, "'utc0' | 'utc8' | 'all'");
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Ticker>>(config, 'Array<Ticker>', authSettings);
    }

    /**
     * Order book will be sorted by price from high to low on bids; low to high on asks
     * @summary Retrieve order book
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.interval Order depth. 0 means no aggregation is applied. default to 0
     * @param opts.limit Maximum number of order depth data in asks or bids
     * @param opts.withId Return order book ID
     */
    public async listOrderBook(
        currencyPair: string,
        opts: { interval?: string; limit?: number; withId?: boolean },
    ): Promise<{ response: AxiosResponse; body: OrderBook }> {
        const localVarPath = this.client.basePath + '/spot/order_book';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listOrderBook.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(opts.interval, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.withId !== undefined) {
            localVarQueryParameters['with_id'] = ObjectSerializer.serialize(opts.withId, 'boolean');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<OrderBook>(config, 'OrderBook', authSettings);
    }

    /**
     * 支持指定 `from` 和 `to` 按时间范围查询或基于 `last_id` 的翻页查询。默认按时间范围查询,查询范围为最近30天。  基于 `last_id` 翻页的查询方式不再推荐继续使用。如果指定 `last_id` ，时间范围查询参数会被忽略。  使用 limit&page分页功能检索数据时最大分页数量为100,000条，即 (limit * page - 1) <= 100000。
     * @summary Retrieve market trades
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records to be returned in a single list.  Default: 100, Minimum: 1, Maximum: 1000
     * @param opts.lastId Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results
     * @param opts.reverse Whether the id of records to be retrieved should be less than the last_id specified. Default to false.  When &#x60;last_id&#x60; is specified. Set &#x60;reverse&#x60; to &#x60;true&#x60; to trace back trading history; &#x60;false&#x60; to retrieve latest tradings.  No effect if &#x60;last_id&#x60; is not specified.
     * @param opts.from Start timestamp of the query
     * @param opts.to Time range ending, default to current time
     * @param opts.page Page number
     */
    public async listTrades(
        currencyPair: string,
        opts: { limit?: number; lastId?: string; reverse?: boolean; from?: number; to?: number; page?: number },
    ): Promise<{ response: AxiosResponse; body: Array<Trade> }> {
        const localVarPath = this.client.basePath + '/spot/trades';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listTrades.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.lastId !== undefined) {
            localVarQueryParameters['last_id'] = ObjectSerializer.serialize(opts.lastId, 'string');
        }

        if (opts.reverse !== undefined) {
            localVarQueryParameters['reverse'] = ObjectSerializer.serialize(opts.reverse, 'boolean');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Trade>>(config, 'Array<Trade>', authSettings);
    }

    /**
     * Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
     * @summary Market candlesticks
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected.
     * @param opts.from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified
     * @param opts.to End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time
     * @param opts.interval Interval time between data points. Note that &#x60;30d&#x60; means 1 natual month, not 30 days
     */
    public async listCandlesticks(
        currencyPair: string,
        opts: {
            limit?: number;
            from?: number;
            to?: number;
            interval?: '10s' | '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d' | '7d' | '30d';
        },
    ): Promise<{ response: AxiosResponse; body: Array<Array<string>> }> {
        const localVarPath = this.client.basePath + '/spot/candlesticks';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listCandlesticks.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(
                opts.interval,
                "'10s' | '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d' | '7d' | '30d'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Array<string>>>(config, 'Array<Array<string>>', authSettings);
    }

    /**
     * This API is deprecated in favour of new fee retrieving API `/wallet/fee`.
     * @summary Query user trading fee rates
     * @param opts Optional parameters
     * @param opts.currencyPair Specify a currency pair to retrieve precise fee rate  This field is optional. In most cases, the fee rate is identical among all currency pairs
     */
    public async getFee(opts: { currencyPair?: string }): Promise<{ response: AxiosResponse; body: SpotFee }> {
        const localVarPath = this.client.basePath + '/spot/fee';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<SpotFee>(config, 'SpotFee', authSettings);
    }

    /**
     *
     * @summary Query a batch of user trading fee rates
     * @param currencyPairs A request can only query up to 50 currency pairs
     */
    public async getBatchSpotFee(
        currencyPairs: string,
    ): Promise<{ response: AxiosResponse; body: { [key: string]: SpotFee } }> {
        const localVarPath = this.client.basePath + '/spot/batch_fee';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPairs' is not null or undefined
        if (currencyPairs === null || currencyPairs === undefined) {
            throw new Error('Required parameter currencyPairs was null or undefined when calling getBatchSpotFee.');
        }

        localVarQueryParameters['currency_pairs'] = ObjectSerializer.serialize(currencyPairs, 'string');

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<{ [key: string]: SpotFee }>(config, '{ [key: string]: SpotFee; }', authSettings);
    }

    /**
     *
     * @summary List spot accounts
     * @param opts Optional parameters
     * @param opts.currency Retrieve data of the specified currency
     */
    public async listSpotAccounts(opts: {
        currency?: string;
    }): Promise<{ response: AxiosResponse; body: Array<SpotAccount> }> {
        const localVarPath = this.client.basePath + '/spot/accounts';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(opts.currency, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SpotAccount>>(config, 'Array<SpotAccount>', authSettings);
    }

    /**
     * 记录查询时间范围不允许超过 30 天。  使用 limit&page分页功能检索数据时最大分页数量为100,000条，即 (limit * page - 1) <= 100000。
     * @summary Query account book
     * @param opts Optional parameters
     * @param opts.currency Retrieve data of the specified currency
     * @param opts.from Start timestamp of the query
     * @param opts.to Time range ending, default to current time
     * @param opts.page Page number
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.type Only retrieve changes of the specified type. All types will be returned if not specified.
     */
    public async listSpotAccountBook(opts: {
        currency?: string;
        from?: number;
        to?: number;
        page?: number;
        limit?: number;
        type?: string;
    }): Promise<{ response: AxiosResponse; body: Array<SpotAccountBook> }> {
        const localVarPath = this.client.basePath + '/spot/account_book';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(opts.currency, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(opts.type, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SpotAccountBook>>(config, 'Array<SpotAccountBook>', authSettings);
    }

    /**
     * Batch orders requirements:  1. custom order field `text` is required 2. At most 4 currency pairs, maximum 10 orders each, are allowed in one request 3. No mixture of spot orders and margin orders, i.e. `account` must be identical for all orders
     * @summary Create a batch of orders
     * @param order
     * @param opts Optional parameters
     * @param opts.xGateExptime 指定过期时间(毫秒); 如果 Gate 收到请求的时间大于过期时间, 请求将被拒绝
     */
    public async createBatchOrders(
        order: Array<Order>,
        opts: { xGateExptime?: number },
    ): Promise<{ response: AxiosResponse; body: Array<BatchOrder> }> {
        const localVarPath = this.client.basePath + '/spot/batch_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling createBatchOrders.');
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(order, 'Array<Order>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<BatchOrder>>(config, 'Array<BatchOrder>', authSettings);
    }

    /**
     * List open orders in all currency pairs.  Note that pagination parameters affect record number in each currency pair\'s open order list. No pagination is applied to the number of currency pairs returned. All currency pairs with open orders will be returned.  Spot,portfolio and margin orders are returned by default. To list cross margin orders, `account` must be set to `cross_margin`
     * @summary List all open orders
     * @param opts Optional parameters
     * @param opts.page Page number
     * @param opts.limit Maximum number of records returned in one page in each currency pair
     * @param opts.account Specify operation account. Default to spot ,portfolio and margin account if not specified. Set to &#x60;cross_margin&#x60; to operate against margin account.  Portfolio margin account must set to &#x60;cross_margin&#x60; only
     */
    public async listAllOpenOrders(opts: {
        page?: number;
        limit?: number;
        account?: string;
    }): Promise<{ response: AxiosResponse; body: Array<OpenOrders> }> {
        const localVarPath = this.client.basePath + '/spot/open_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OpenOrders>>(config, 'Array<OpenOrders>', authSettings);
    }

    /**
     * Currently, only cross-margin accounts are supported to close position when cross currencies are disabled.  Maximum buy quantity = (unpaid principal and interest - currency balance - the amount of the currency in the order book) / 0.998
     * @summary close position when cross-currency is disabled
     * @param liquidateOrder
     */
    public async createCrossLiquidateOrder(
        liquidateOrder: LiquidateOrder,
    ): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath = this.client.basePath + '/spot/cross_liquidate_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'liquidateOrder' is not null or undefined
        if (liquidateOrder === null || liquidateOrder === undefined) {
            throw new Error(
                'Required parameter liquidateOrder was null or undefined when calling createCrossLiquidateOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(liquidateOrder, 'LiquidateOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * Spot, portfolio and margin orders are returned by default. If cross margin orders are needed, `account` must be set to `cross_margin`  When `status` is `open`, i.e., listing open orders, only pagination parameters `page` and `limit` are supported and `limit` cannot be larger than 100. Query by `side` and time range parameters `from` and `to` are not supported.  When `status` is `finished`, i.e., listing finished orders, pagination parameters, time range parameters `from` and `to`, and `side` parameters are all supported. Time range parameters are handled as order finish time.
     * @summary List orders
     * @param currencyPair Retrieve results with specified currency pair. It is required for open orders, but optional for finished ones.
     * @param status List orders based on status  &#x60;open&#x60; - order is waiting to be filled &#x60;finished&#x60; - order has been filled or cancelled
     * @param opts Optional parameters
     * @param opts.page Page number
     * @param opts.limit Maximum number of records to be returned. If &#x60;status&#x60; is &#x60;open&#x60;, maximum of &#x60;limit&#x60; is 100
     * @param opts.account Specify operation account. Default to spot ,portfolio and margin account if not specified. Set to &#x60;cross_margin&#x60; to operate against margin account.  Portfolio margin account must set to &#x60;cross_margin&#x60; only
     * @param opts.from Start timestamp of the query
     * @param opts.to Time range ending, default to current time
     * @param opts.side All bids or asks. Both included if not specified
     */
    public async listOrders(
        currencyPair: string,
        status: string,
        opts: { page?: number; limit?: number; account?: string; from?: number; to?: number; side?: string },
    ): Promise<{ response: AxiosResponse; body: Array<Order> }> {
        const localVarPath = this.client.basePath + '/spot/orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listOrders.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling listOrders.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, 'string');

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.side !== undefined) {
            localVarQueryParameters['side'] = ObjectSerializer.serialize(opts.side, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Order>>(config, 'Array<Order>', authSettings);
    }

    /**
     * 支持现货、保证金、杠杆、全仓杠杆下单。通过 `account` 字段来使用不同的账户，默认为 `spot` ，即使用现货账户下单，如果用户是 `unified` 账户，默认是用统一账户下单  使用杠杆账户交易，即 `account` 设置为 `margin` 的时候，可以设置 `auto_borrow` 为 `true`， 在账户余额不足的情况，由系统自动执行 `POST /margin/uni/loans` 借入不足部分。 杠杆下单成交之后的获取到的资产是否自动用于归还逐仓杠杆账户的借入单，取决于用户逐仓杠杆**账户**的自动还款设置， 该账户自动还款设置可以通过 `/margin/auto_repay` 来查询和设置。  使用全仓杠杆账户交易，即 `account` 设置为 `cross_margin` 的时候，同样可以启用 `auto_borrow` 来实现自动借入不足部分，但是与逐仓杠杆账户不同的是，全仓杠杆账户的委托是否自动还款取决于下单时的 `auto_repay` 设置，该设置只对当前委托生效，即只有该委托成交之后获取到的资产会用来还款全仓杠杆账户的借入单。 全仓杠杆账户下单目前支持同时开启 `auto_borrow` 和 `auto_repay`。  自动还款会在订单结束时触发，即 `status` 为 `cancelled` 或者 `closed` 。  **委托状态**  挂单中的委托状态是 `open` ，在数量全部成交之前保持为 `open` 。如果被全部吃掉，则订单结束，状态变成 `closed` 。 假如全部成交之前，订单被撤销，不管是否有部分成交，状态都会变为 `cancelled`  **冰山委托**  `iceberg` 用来设置冰山委托显示的数量，如果需要完全隐藏，设置为 `-1` 。注意隐藏部分成交时按照 taker 的手续费率收取。  **限制用户自成交**  设置 `stp_act` 来决定使用限制用户自成交的策略
     * @summary Create an order
     * @param order
     * @param opts Optional parameters
     * @param opts.xGateExptime 指定过期时间(毫秒); 如果 Gate 收到请求的时间大于过期时间, 请求将被拒绝
     */
    public async createOrder(
        order: Order,
        opts: { xGateExptime?: number },
    ): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath = this.client.basePath + '/spot/orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling createOrder.');
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(order, 'Order'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * 不指定 `account` 参数时，包括现货、保证金、逐仓杠杆和全仓杠杆在内的所有挂单都会执行撤销操作。 不指定 `currency_pair`时，会撤销所有交易对的挂单 可以单独指定某一种账户，撤销指定账户下的所有挂单
     * @summary Cancel all `open` orders in specified currency pair
     * @param opts Optional parameters
     * @param opts.currencyPair Currency pair
     * @param opts.side All bids or asks. Both included if not specified
     * @param opts.account 指定账户类型  - 经典账户：不指定则全部包含   - 统一账户：指定&#x60;unified&#x60; - 统一账户(旧)：只能指定&#x60;cross_margin&#x60;
     * @param opts.actionMode Processing Mode  When placing an order, different fields are returned based on the action_mode  - ACK: Asynchronous mode, returns only key order fields - RESULT: No clearing information - FULL: Full mode (default)
     * @param opts.xGateExptime 指定过期时间(毫秒); 如果 Gate 收到请求的时间大于过期时间, 请求将被拒绝
     */
    public async cancelOrders(opts: {
        currencyPair?: string;
        side?: string;
        account?: string;
        actionMode?: string;
        xGateExptime?: number;
    }): Promise<{ response: AxiosResponse; body: Array<OrderCancel> }> {
        const localVarPath = this.client.basePath + '/spot/orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        if (opts.side !== undefined) {
            localVarQueryParameters['side'] = ObjectSerializer.serialize(opts.side, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        if (opts.actionMode !== undefined) {
            localVarQueryParameters['action_mode'] = ObjectSerializer.serialize(opts.actionMode, 'string');
        }

        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OrderCancel>>(config, 'Array<OrderCancel>', authSettings);
    }

    /**
     * Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
     * @summary Cancel a batch of orders with an ID list
     * @param cancelBatchOrder
     * @param opts Optional parameters
     * @param opts.xGateExptime 指定过期时间(毫秒); 如果 Gate 收到请求的时间大于过期时间, 请求将被拒绝
     */
    public async cancelBatchOrders(
        cancelBatchOrder: Array<CancelBatchOrder>,
        opts: { xGateExptime?: number },
    ): Promise<{ response: AxiosResponse; body: Array<CancelOrderResult> }> {
        const localVarPath = this.client.basePath + '/spot/cancel_batch_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'cancelBatchOrder' is not null or undefined
        if (cancelBatchOrder === null || cancelBatchOrder === undefined) {
            throw new Error(
                'Required parameter cancelBatchOrder was null or undefined when calling cancelBatchOrders.',
            );
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(cancelBatchOrder, 'Array<CancelBatchOrder>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<CancelOrderResult>>(config, 'Array<CancelOrderResult>', authSettings);
    }

    /**
     * Spot, portfolio and margin orders are queried by default. If cross margin orders are needed or portfolio margin account are used, account must be set to cross_margin.
     * @summary Get a single order
     * @param orderId Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 1 hour after the end of the order.  After that, only order ID is accepted.
     * @param currencyPair 指定交易对查询。如果查询挂单的记录，该字段必选。如果查询已成交的记录，该字段可以不指定
     * @param opts Optional parameters
     * @param opts.account Specify operation account. Default to spot ,portfolio and margin account if not specified. Set to &#x60;cross_margin&#x60; to operate against margin account.  Portfolio margin account must set to &#x60;cross_margin&#x60; only
     */
    public async getOrder(
        orderId: string,
        currencyPair: string,
        opts: { account?: string },
    ): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath =
            this.client.basePath +
            '/spot/orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrder.');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling getOrder.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * Spot,portfolio and margin orders are cancelled by default. If trying to cancel cross margin orders or portfolio margin account are used, account must be set to cross_margin
     * @summary Cancel a single order
     * @param orderId Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 1 hour after the end of the order.  After that, only order ID is accepted.
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.account Specify operation account. Default to spot ,portfolio and margin account if not specified. Set to &#x60;cross_margin&#x60; to operate against margin account.  Portfolio margin account must set to &#x60;cross_margin&#x60; only
     * @param opts.actionMode Processing Mode  When placing an order, different fields are returned based on the action_mode  - ACK: Asynchronous mode, returns only key order fields - RESULT: No clearing information - FULL: Full mode (default)
     * @param opts.xGateExptime 指定过期时间(毫秒); 如果 Gate 收到请求的时间大于过期时间, 请求将被拒绝
     */
    public async cancelOrder(
        orderId: string,
        currencyPair: string,
        opts: { account?: string; actionMode?: string; xGateExptime?: number },
    ): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath =
            this.client.basePath +
            '/spot/orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelOrder.');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling cancelOrder.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        if (opts.actionMode !== undefined) {
            localVarQueryParameters['action_mode'] = ObjectSerializer.serialize(opts.actionMode, 'string');
        }

        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * 默认修改现货、保证金和逐仓杠杆账户的订单，如果需要修改全仓杠杆账户订单，必须指定 `account` 为 `cross_margin`，统一账户 `account` 只能指定为 `cross_margin`。  目前请求体和query都支持currency_pair和account传参，但请求体优先级更高  currency_pair必须在请求体或query中二选一填入  目前只支持修改价格或数量（二选一）  关于限速：修改订单和创建订单共享限速规则  关于匹配优先级：只修改数量变小不影响匹配优先级，修改价格或修改数量变大则优先级将调整到新价格最后面    注意事项:修改数量小于已成交数量会触发撤单操作
     * @summary Amend an order
     * @param orderId Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 1 hour after the end of the order.  After that, only order ID is accepted.
     * @param orderPatch
     * @param opts Optional parameters
     * @param opts.currencyPair Currency pair
     * @param opts.account Specify operation account. Default to spot ,portfolio and margin account if not specified. Set to &#x60;cross_margin&#x60; to operate against margin account.  Portfolio margin account must set to &#x60;cross_margin&#x60; only
     * @param opts.xGateExptime 指定过期时间(毫秒); 如果 Gate 收到请求的时间大于过期时间, 请求将被拒绝
     */
    public async amendOrder(
        orderId: string,
        orderPatch: OrderPatch,
        opts: { currencyPair?: string; account?: string; xGateExptime?: number },
    ): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath =
            this.client.basePath +
            '/spot/orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling amendOrder.');
        }

        // verify required parameter 'orderPatch' is not null or undefined
        if (orderPatch === null || orderPatch === undefined) {
            throw new Error('Required parameter orderPatch was null or undefined when calling amendOrder.');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'PATCH',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(orderPatch, 'OrderPatch'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * 默认查询现货、保证金和逐仓杠杆账户的成交记录，如果需要查询全仓杠杆账户的成交记录，必须指定 `account` 为 `cross_margin` 。  可以通过指定 `from` 或(和) `to` 来查询指定时间范围内的历史。  - 如果不指定任何时间参数，只能获取最近 7 天的数据。 - 如果只指定 `from` 或 `to` 的任一参数，也同样只返回指定时间开始（或结束）的 7 天范围的数据。 - `from` 和 `to` 的范围不允许超过 30 天 。  时间范围筛选的参数均是按订单**结束**时间来处理。  使用 limit&page分页功能检索数据时最大分页数量为100,000条，即 (limit * page - 1) <= 100000。
     * @summary List personal trading history
     * @param opts Optional parameters
     * @param opts.currencyPair Retrieve results with specified currency pair
     * @param opts.limit Maximum number of records to be returned in a single list.  Default: 100, Minimum: 1, Maximum: 1000
     * @param opts.page Page number
     * @param opts.orderId Filter trades with specified order ID. &#x60;currency_pair&#x60; is also required if this field is present
     * @param opts.account Specify operation account. Default to spot ,portfolio and margin account if not specified. Set to &#x60;cross_margin&#x60; to operate against margin account.  Portfolio margin account must set to &#x60;cross_margin&#x60; only
     * @param opts.from Start timestamp of the query
     * @param opts.to Time range ending, default to current time
     */
    public async listMyTrades(opts: {
        currencyPair?: string;
        limit?: number;
        page?: number;
        orderId?: string;
        account?: string;
        from?: number;
        to?: number;
    }): Promise<{ response: AxiosResponse; body: Array<Trade> }> {
        const localVarPath = this.client.basePath + '/spot/my_trades';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.orderId !== undefined) {
            localVarQueryParameters['order_id'] = ObjectSerializer.serialize(opts.orderId, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Trade>>(config, 'Array<Trade>', authSettings);
    }

    /**
     *
     * @summary Get server current time
     */
    public async getSystemTime(): Promise<{ response: AxiosResponse; body: SystemTime }> {
        const localVarPath = this.client.basePath + '/spot/time';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<SystemTime>(config, 'SystemTime', authSettings);
    }

    /**
     * When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown`timeout` is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified `market` will be automatically cancelled, if no `market` is specified, all market pending orders will be cancelled. If the `timeout` is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
     * @summary Countdown cancel orders
     * @param countdownCancelAllSpotTask
     */
    public async countdownCancelAllSpot(
        countdownCancelAllSpotTask: CountdownCancelAllSpotTask,
    ): Promise<{ response: AxiosResponse; body: TriggerTime }> {
        const localVarPath = this.client.basePath + '/spot/countdown_cancel_all';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'countdownCancelAllSpotTask' is not null or undefined
        if (countdownCancelAllSpotTask === null || countdownCancelAllSpotTask === undefined) {
            throw new Error(
                'Required parameter countdownCancelAllSpotTask was null or undefined when calling countdownCancelAllSpot.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(countdownCancelAllSpotTask, 'CountdownCancelAllSpotTask'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerTime>(config, 'TriggerTime', authSettings);
    }

    /**
     * Default modification of orders for spot, portfolio, and margin accounts. To modify orders for a cross margin account, the `account` parameter must be specified as `cross_margin`.  For portfolio margin accounts, the `account` parameter can only be specified as `cross_margin`. Currently, only modifications to price or quantity (choose one) are supported. When modifying unfinished orders, a maximum of 5 orders can be batch-modified in one request. The request parameters should be passed in an array format. During batch modification, if one order modification fails, the modification process will continue with the next order. After execution, the response will include corresponding failure information for the failed orders. The sequence of calling for batch order modification should be consistent with the order in the order list. The response content order for batch order modification will also be consistent with the order in the order list.
     * @summary Batch modification of orders
     * @param batchAmendItem
     * @param opts Optional parameters
     * @param opts.xGateExptime 指定过期时间(毫秒); 如果 Gate 收到请求的时间大于过期时间, 请求将被拒绝
     */
    public async amendBatchOrders(
        batchAmendItem: Array<BatchAmendItem>,
        opts: { xGateExptime?: number },
    ): Promise<{ response: AxiosResponse; body: Array<BatchOrder> }> {
        const localVarPath = this.client.basePath + '/spot/amend_batch_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'batchAmendItem' is not null or undefined
        if (batchAmendItem === null || batchAmendItem === undefined) {
            throw new Error('Required parameter batchAmendItem was null or undefined when calling amendBatchOrders.');
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(batchAmendItem, 'Array<BatchAmendItem>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<BatchOrder>>(config, 'Array<BatchOrder>', authSettings);
    }

    /**
     *
     * @summary 查询现货保险基金历史数据
     * @param business 杠杆业务，margin - 逐仓；unified - 统一账户
     * @param currency Currency
     * @param from 起始时间戳，秒级
     * @param to 终止时间戳，秒级
     * @param opts Optional parameters
     * @param opts.page Page number
     * @param opts.limit 列表返回的最大数量, 默认值30
     */
    public async getSpotInsuranceHistory(
        business: string,
        currency: string,
        from: number,
        to: number,
        opts: { page?: number; limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<SpotInsuranceHistory> }> {
        const localVarPath = this.client.basePath + '/spot/insurance_history';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'business' is not null or undefined
        if (business === null || business === undefined) {
            throw new Error('Required parameter business was null or undefined when calling getSpotInsuranceHistory.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling getSpotInsuranceHistory.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling getSpotInsuranceHistory.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling getSpotInsuranceHistory.');
        }

        opts = opts || {};
        localVarQueryParameters['business'] = ObjectSerializer.serialize(business, 'string');

        localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, 'string');

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        localVarQueryParameters['from'] = ObjectSerializer.serialize(from, 'number');

        localVarQueryParameters['to'] = ObjectSerializer.serialize(to, 'number');

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<SpotInsuranceHistory>>(config, 'Array<SpotInsuranceHistory>', authSettings);
    }

    /**
     *
     * @summary Retrieve running auto order list
     * @param status Only list the orders with this status
     * @param opts Optional parameters
     * @param opts.market Currency pair
     * @param opts.account Trading account type.  Portfolio margin account must set to &#x60;cross_margin&#x60;
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listSpotPriceTriggeredOrders(
        status: 'open' | 'finished',
        opts: { market?: string; account?: 'normal' | 'margin' | 'cross_margin'; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<SpotPriceTriggeredOrder> }> {
        const localVarPath = this.client.basePath + '/spot/price_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error(
                'Required parameter status was null or undefined when calling listSpotPriceTriggeredOrders.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'open' | 'finished'");

        if (opts.market !== undefined) {
            localVarQueryParameters['market'] = ObjectSerializer.serialize(opts.market, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(
                opts.account,
                "'normal' | 'margin' | 'cross_margin'",
            );
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SpotPriceTriggeredOrder>>(
            config,
            'Array<SpotPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Create a price-triggered order
     * @param spotPriceTriggeredOrder
     */
    public async createSpotPriceTriggeredOrder(
        spotPriceTriggeredOrder: SpotPriceTriggeredOrder,
    ): Promise<{ response: AxiosResponse; body: TriggerOrderResponse }> {
        const localVarPath = this.client.basePath + '/spot/price_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'spotPriceTriggeredOrder' is not null or undefined
        if (spotPriceTriggeredOrder === null || spotPriceTriggeredOrder === undefined) {
            throw new Error(
                'Required parameter spotPriceTriggeredOrder was null or undefined when calling createSpotPriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(spotPriceTriggeredOrder, 'SpotPriceTriggeredOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerOrderResponse>(config, 'TriggerOrderResponse', authSettings);
    }

    /**
     *
     * @summary Cancel all open orders
     * @param opts Optional parameters
     * @param opts.market Currency pair
     * @param opts.account Trading account type.  Portfolio margin account must set to &#x60;cross_margin&#x60;
     */
    public async cancelSpotPriceTriggeredOrderList(opts: {
        market?: string;
        account?: 'normal' | 'margin' | 'cross_margin';
    }): Promise<{ response: AxiosResponse; body: Array<SpotPriceTriggeredOrder> }> {
        const localVarPath = this.client.basePath + '/spot/price_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.market !== undefined) {
            localVarQueryParameters['market'] = ObjectSerializer.serialize(opts.market, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(
                opts.account,
                "'normal' | 'margin' | 'cross_margin'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SpotPriceTriggeredOrder>>(
            config,
            'Array<SpotPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Get a price-triggered order
     * @param orderId Retrieve the data of the order with the specified ID
     */
    public async getSpotPriceTriggeredOrder(
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: SpotPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/spot/price_orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error(
                'Required parameter orderId was null or undefined when calling getSpotPriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<SpotPriceTriggeredOrder>(config, 'SpotPriceTriggeredOrder', authSettings);
    }

    /**
     *
     * @summary cancel a price-triggered order
     * @param orderId Retrieve the data of the order with the specified ID
     */
    public async cancelSpotPriceTriggeredOrder(
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: SpotPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/spot/price_orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error(
                'Required parameter orderId was null or undefined when calling cancelSpotPriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<SpotPriceTriggeredOrder>(config, 'SpotPriceTriggeredOrder', authSettings);
    }
}
