/**
 * Gate API v4
 * Welcome to Gate.io API  APIv4 provides spot, margin and futures trading operations. There are public APIs to retrieve the real-time market statistics, and private APIs which needs authentication to trade on user\'s behalf.
 *
 * Contact: support@mail.gate.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-locals */
import { BatchOrder } from '../model/batchOrder';
import { CancelOrder } from '../model/cancelOrder';
import { CancelOrderResult } from '../model/cancelOrderResult';
import { Currency } from '../model/currency';
import { CurrencyPair } from '../model/currencyPair';
import { OpenOrders } from '../model/openOrders';
import { Order } from '../model/order';
import { OrderBook } from '../model/orderBook';
import { SpotAccount } from '../model/spotAccount';
import { SpotPriceTriggeredOrder } from '../model/spotPriceTriggeredOrder';
import { Ticker } from '../model/ticker';
import { Trade } from '../model/trade';
import { TradeFee } from '../model/tradeFee';
import { TriggerOrderResponse } from '../model/triggerOrderResponse';
import { ObjectSerializer } from '../model/models';
import { ApiClient } from './apiClient';
import { AxiosRequestConfig, AxiosResponse } from 'axios';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class SpotApi {
    protected client: ApiClient;

    constructor(client?: ApiClient) {
        if (client) {
            this.client = client;
        } else {
            this.client = new ApiClient();
        }
    }

    /**
     * Currency has two forms:  1. Only currency name, e.g., BTC, USDT 2. `<currency>_<chain>`, e.g., `HT_ETH`  The latter one occurs when one currency has multiple chains. Currency detail contains a `chain` field whatever the form is. To retrieve all chains of one currency, you can use use all the details which has the name of the currency or name starting with `<currency>_`.
     * @summary List all currencies\' details
     */
    public async listCurrencies(): Promise<{ response: AxiosResponse; body: Array<Currency> }> {
        const localVarPath = this.client.basePath + '/spot/currencies';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Currency>>(config, 'Array<Currency>', authSettings);
    }

    /**
     *
     * @summary Get details of a specific currency
     * @param currency Currency name
     */
    public async getCurrency(currency: string): Promise<{ response: AxiosResponse; body: Currency }> {
        const localVarPath =
            this.client.basePath +
            '/spot/currencies/{currency}'.replace('{' + 'currency' + '}', encodeURIComponent(String(currency)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling getCurrency.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Currency>(config, 'Currency', authSettings);
    }

    /**
     *
     * @summary List all currency pairs supported
     */
    public async listCurrencyPairs(): Promise<{ response: AxiosResponse; body: Array<CurrencyPair> }> {
        const localVarPath = this.client.basePath + '/spot/currency_pairs';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<CurrencyPair>>(config, 'Array<CurrencyPair>', authSettings);
    }

    /**
     *
     * @summary Get details of a specifc order
     * @param currencyPair Currency pair
     */
    public async getCurrencyPair(currencyPair: string): Promise<{ response: AxiosResponse; body: CurrencyPair }> {
        const localVarPath =
            this.client.basePath +
            '/spot/currency_pairs/{currency_pair}'.replace(
                '{' + 'currency_pair' + '}',
                encodeURIComponent(String(currencyPair)),
            );
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling getCurrencyPair.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<CurrencyPair>(config, 'CurrencyPair', authSettings);
    }

    /**
     * Return only related data if `currency_pair` is specified; otherwise return all of them
     * @summary Retrieve ticker information
     * @param opts Optional parameters
     * @param opts.currencyPair Currency pair
     */
    public async listTickers(opts: {
        currencyPair?: string;
    }): Promise<{ response: AxiosResponse; body: Array<Ticker> }> {
        const localVarPath = this.client.basePath + '/spot/tickers';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Ticker>>(config, 'Array<Ticker>', authSettings);
    }

    /**
     * Order book will be sorted by price from high to low on bids; low to high on asks
     * @summary Retrieve order book
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.interval Order depth. 0 means no aggregation is applied. default to 0
     * @param opts.limit Maximum number of order depth data in asks or bids
     * @param opts.withId Return order book ID
     */
    public async listOrderBook(
        currencyPair: string,
        opts: { interval?: string; limit?: number; withId?: boolean },
    ): Promise<{ response: AxiosResponse; body: OrderBook }> {
        const localVarPath = this.client.basePath + '/spot/order_book';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listOrderBook.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(opts.interval, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.withId !== undefined) {
            localVarQueryParameters['with_id'] = ObjectSerializer.serialize(opts.withId, 'boolean');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<OrderBook>(config, 'OrderBook', authSettings);
    }

    /**
     * You can use `from` and `to` to query by time range, or use `last_id` by scrolling page. The default behavior is by time range.  Scrolling query using `last_id` is not recommended any more. If `last_id` is specified, time range query parameters will be ignored.
     * @summary Retrieve market trades
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.lastId Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results
     * @param opts.reverse Whether the id of records to be retrieved should be less than the last_id specified. Default to false.  When &#x60;last_id&#x60; is specified. Set &#x60;reverse&#x60; to &#x60;true&#x60; to trace back trading history; &#x60;false&#x60; to retrieve latest tradings.  No effect if &#x60;last_id&#x60; is not specified.
     * @param opts.from Start timestamp of the query
     * @param opts.to Time range ending, default to current time
     * @param opts.page Page number
     */
    public async listTrades(
        currencyPair: string,
        opts: { limit?: number; lastId?: string; reverse?: boolean; from?: number; to?: number; page?: number },
    ): Promise<{ response: AxiosResponse; body: Array<Trade> }> {
        const localVarPath = this.client.basePath + '/spot/trades';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listTrades.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.lastId !== undefined) {
            localVarQueryParameters['last_id'] = ObjectSerializer.serialize(opts.lastId, 'string');
        }

        if (opts.reverse !== undefined) {
            localVarQueryParameters['reverse'] = ObjectSerializer.serialize(opts.reverse, 'boolean');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Trade>>(config, 'Array<Trade>', authSettings);
    }

    /**
     * Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
     * @summary Market candlesticks
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected.
     * @param opts.from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified
     * @param opts.to End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time
     * @param opts.interval Interval time between data points. Note that &#x60;30d&#x60; means 1 natual month, not 30 days
     */
    public async listCandlesticks(
        currencyPair: string,
        opts: {
            limit?: number;
            from?: number;
            to?: number;
            interval?: '10s' | '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d' | '7d' | '30d';
        },
    ): Promise<{ response: AxiosResponse; body: Array<Array<string>> }> {
        const localVarPath = this.client.basePath + '/spot/candlesticks';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listCandlesticks.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(
                opts.interval,
                "'10s' | '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d' | '7d' | '30d'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Array<string>>>(config, 'Array<Array<string>>', authSettings);
    }

    /**
     * This API is deprecated in favour of new fee retrieving API `/wallet/fee`.
     * @summary Query user trading fee rates
     * @param opts Optional parameters
     * @param opts.currencyPair Specify a currency pair to retrieve precise fee rate  This field is optional. In most cases, the fee rate is identical among all currency pairs
     */
    public async getFee(opts: { currencyPair?: string }): Promise<{ response: AxiosResponse; body: TradeFee }> {
        const localVarPath = this.client.basePath + '/spot/fee';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<TradeFee>(config, 'TradeFee', authSettings);
    }

    /**
     *
     * @summary List spot accounts
     * @param opts Optional parameters
     * @param opts.currency Retrieve data of the specified currency
     */
    public async listSpotAccounts(opts: {
        currency?: string;
    }): Promise<{ response: AxiosResponse; body: Array<SpotAccount> }> {
        const localVarPath = this.client.basePath + '/spot/accounts';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(opts.currency, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SpotAccount>>(config, 'Array<SpotAccount>', authSettings);
    }

    /**
     * Batch orders requirements:  1. custom order field `text` is required 2. At most 4 currency pairs, maximum 10 orders each, are allowed in one request 3. No mixture of spot orders and margin orders, i.e. `account` must be identical for all orders
     * @summary Create a batch of orders
     * @param order
     */
    public async createBatchOrders(order: Array<Order>): Promise<{ response: AxiosResponse; body: Array<BatchOrder> }> {
        const localVarPath = this.client.basePath + '/spot/batch_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling createBatchOrders.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(order, 'Array<Order>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<BatchOrder>>(config, 'Array<BatchOrder>', authSettings);
    }

    /**
     * List open orders in all currency pairs.  Note that pagination parameters affect record number in each currency pair\'s open order list. No pagination is applied to the number of currency pairs returned. All currency pairs with open orders will be returned.  Spot and margin orders are returned by default. To list cross margin orders, `account` must be set to `cross_margin`
     * @summary List all open orders
     * @param opts Optional parameters
     * @param opts.page Page number
     * @param opts.limit Maximum number of records returned in one page in each currency pair
     * @param opts.account Specify operation account. Default to spot and margin account if not specified. Set to &#x60;cross_margin&#x60; to operate against margin account
     */
    public async listAllOpenOrders(opts: {
        page?: number;
        limit?: number;
        account?: string;
    }): Promise<{ response: AxiosResponse; body: Array<OpenOrders> }> {
        const localVarPath = this.client.basePath + '/spot/open_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OpenOrders>>(config, 'Array<OpenOrders>', authSettings);
    }

    /**
     * Spot and margin orders are returned by default. If cross margin orders are needed, `account` must be set to `cross_margin`  When `status` is `open`, i.e., listing open orders, only pagination parameters `page` and `limit` are supported and `limit` cannot be larger than 100. Query by `side` and time range parameters `from` and `to` are not supported.  When `status` is `finished`, i.e., listing finished orders, pagination parameters, time range parameters `from` and `to`, and `side` parameters are all supported. Time range parameters are handled as order finish time.
     * @summary List orders
     * @param currencyPair Retrieve results with specified currency pair. It is required for open orders, but optional for finished ones.
     * @param status List orders based on status  &#x60;open&#x60; - order is waiting to be filled &#x60;finished&#x60; - order has been filled or cancelled
     * @param opts Optional parameters
     * @param opts.page Page number
     * @param opts.limit Maximum number of records to be returned. If &#x60;status&#x60; is &#x60;open&#x60;, maximum of &#x60;limit&#x60; is 100
     * @param opts.account Specify operation account. Default to spot and margin account if not specified. Set to &#x60;cross_margin&#x60; to operate against margin account
     * @param opts.from Start timestamp of the query
     * @param opts.to Time range ending, default to current time
     * @param opts.side All bids or asks. Both included if not specified
     */
    public async listOrders(
        currencyPair: string,
        status: 'open' | 'finished',
        opts: { page?: number; limit?: number; account?: string; from?: number; to?: number; side?: 'buy' | 'sell' },
    ): Promise<{ response: AxiosResponse; body: Array<Order> }> {
        const localVarPath = this.client.basePath + '/spot/orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listOrders.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling listOrders.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'open' | 'finished'");

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.side !== undefined) {
            localVarQueryParameters['side'] = ObjectSerializer.serialize(opts.side, "'buy' | 'sell'");
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Order>>(config, 'Array<Order>', authSettings);
    }

    /**
     * You can place orders with spot, margin or cross margin account through setting the `account `field. It defaults to `spot`, which means spot account is used to place orders.  When margin account is used, i.e., `account` is `margin`, `auto_borrow` field can be set to `true` to enable the server to borrow the amount lacked using `POST /margin/loans` when your account\'s balance is not enough. Whether margin orders\' fill will be used to repay margin loans automatically is determined by the auto repayment setting in your **margin account**, which can be updated or queried using `/margin/auto_repay` API.  When cross margin account is used, i.e., `account` is `cross_margin`, `auto_borrow` can also be enabled to achieve borrowing the insufficient amount automatically if cross account\'s balance is not enough. But it differs from margin account that automatic repayment is determined by order\'s `auto_repay` field and only current order\'s fill will be used to repay cross margin loans.  Automatic repayment will be triggered when the order is finished, i.e., its status is either `cancelled` or `closed`.  **Order status**  An order waiting to be filled is `open`, and it stays `open` until it is filled totally. If fully filled, order is finished and its status turns to `closed`.If the order is cancelled before it is totally filled, whether or not partially filled, its status is `cancelled`. **Iceberg order**  `iceberg` field can be used to set the amount shown. Set to `-1` to hide the order completely. Note that the hidden part\'s fee will be charged using taker\'s fee rate.
     * @summary Create an order
     * @param order
     */
    public async createOrder(order: Order): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath = this.client.basePath + '/spot/orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling createOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(order, 'Order'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * If `account` is not set, all open orders, including spot, margin and cross margin ones, will be cancelled.  You can set `account` to cancel only orders within the specified account
     * @summary Cancel all `open` orders in specified currency pair
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.side All bids or asks. Both included if not specified
     * @param opts.account Specify account type. Default to all account types being included
     */
    public async cancelOrders(
        currencyPair: string,
        opts: { side?: 'buy' | 'sell'; account?: 'spot' | 'margin' | 'cross_margin' },
    ): Promise<{ response: AxiosResponse; body: Array<Order> }> {
        const localVarPath = this.client.basePath + '/spot/orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling cancelOrders.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.side !== undefined) {
            localVarQueryParameters['side'] = ObjectSerializer.serialize(opts.side, "'buy' | 'sell'");
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(
                opts.account,
                "'spot' | 'margin' | 'cross_margin'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Order>>(config, 'Array<Order>', authSettings);
    }

    /**
     * Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
     * @summary Cancel a batch of orders with an ID list
     * @param cancelOrder
     */
    public async cancelBatchOrders(
        cancelOrder: Array<CancelOrder>,
    ): Promise<{ response: AxiosResponse; body: Array<CancelOrderResult> }> {
        const localVarPath = this.client.basePath + '/spot/cancel_batch_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'cancelOrder' is not null or undefined
        if (cancelOrder === null || cancelOrder === undefined) {
            throw new Error('Required parameter cancelOrder was null or undefined when calling cancelBatchOrders.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(cancelOrder, 'Array<CancelOrder>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<CancelOrderResult>>(config, 'Array<CancelOrderResult>', authSettings);
    }

    /**
     * Spot and margin orders are queried by default. If cross margin orders are needed, `account` must be set to `cross_margin`
     * @summary Get a single order
     * @param orderId Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID are accepted only in the first 30 minutes after order creation.After that, only order ID is accepted.
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.account Specify operation account. Default to spot and margin account if not specified. Set to &#x60;cross_margin&#x60; to operate against margin account
     */
    public async getOrder(
        orderId: string,
        currencyPair: string,
        opts: { account?: string },
    ): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath =
            this.client.basePath +
            '/spot/orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrder.');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling getOrder.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * Spot and margin orders are cancelled by default. If trying to cancel cross margin orders, `account` must be set to `cross_margin`
     * @summary Cancel a single order
     * @param orderId Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID are accepted only in the first 30 minutes after order creation.After that, only order ID is accepted.
     * @param currencyPair Currency pair
     * @param opts Optional parameters
     * @param opts.account Specify operation account. Default to spot and margin account if not specified. Set to &#x60;cross_margin&#x60; to operate against margin account
     */
    public async cancelOrder(
        orderId: string,
        currencyPair: string,
        opts: { account?: string },
    ): Promise<{ response: AxiosResponse; body: Order }> {
        const localVarPath =
            this.client.basePath +
            '/spot/orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelOrder.');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling cancelOrder.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Order>(config, 'Order', authSettings);
    }

    /**
     * Spot and margin trades are queried by default. If cross margin trades are needed, `account` must be set to `cross_margin`  You can also set `from` and(or) `to` to query by time range Time range parameters are handled as order finish time.
     * @summary List personal trading history
     * @param currencyPair Retrieve results with specified currency pair. It is required for open orders, but optional for finished ones.
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.page Page number
     * @param opts.orderId Filter trades with specified order ID. &#x60;currency_pair&#x60; is also required if this field is present
     * @param opts.account Specify operation account. Default to spot and margin account if not specified. Set to &#x60;cross_margin&#x60; to operate against margin account
     * @param opts.from Start timestamp of the query
     * @param opts.to Time range ending, default to current time
     */
    public async listMyTrades(
        currencyPair: string,
        opts: { limit?: number; page?: number; orderId?: string; account?: string; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<Trade> }> {
        const localVarPath = this.client.basePath + '/spot/my_trades';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currencyPair' is not null or undefined
        if (currencyPair === null || currencyPair === undefined) {
            throw new Error('Required parameter currencyPair was null or undefined when calling listMyTrades.');
        }

        opts = opts || {};
        localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(currencyPair, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.orderId !== undefined) {
            localVarQueryParameters['order_id'] = ObjectSerializer.serialize(opts.orderId, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Trade>>(config, 'Array<Trade>', authSettings);
    }

    /**
     *
     * @summary Retrieve running auto order list
     * @param status Only list the orders with this status
     * @param opts Optional parameters
     * @param opts.market Currency pair
     * @param opts.account Trading account
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listSpotPriceTriggeredOrders(
        status: 'open' | 'finished',
        opts: { market?: string; account?: 'normal' | 'margin'; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<SpotPriceTriggeredOrder> }> {
        const localVarPath = this.client.basePath + '/spot/price_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error(
                'Required parameter status was null or undefined when calling listSpotPriceTriggeredOrders.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'open' | 'finished'");

        if (opts.market !== undefined) {
            localVarQueryParameters['market'] = ObjectSerializer.serialize(opts.market, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, "'normal' | 'margin'");
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SpotPriceTriggeredOrder>>(
            config,
            'Array<SpotPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Create a price-triggered order
     * @param spotPriceTriggeredOrder
     */
    public async createSpotPriceTriggeredOrder(
        spotPriceTriggeredOrder: SpotPriceTriggeredOrder,
    ): Promise<{ response: AxiosResponse; body: TriggerOrderResponse }> {
        const localVarPath = this.client.basePath + '/spot/price_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'spotPriceTriggeredOrder' is not null or undefined
        if (spotPriceTriggeredOrder === null || spotPriceTriggeredOrder === undefined) {
            throw new Error(
                'Required parameter spotPriceTriggeredOrder was null or undefined when calling createSpotPriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(spotPriceTriggeredOrder, 'SpotPriceTriggeredOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerOrderResponse>(config, 'TriggerOrderResponse', authSettings);
    }

    /**
     *
     * @summary Cancel all open orders
     * @param opts Optional parameters
     * @param opts.market Currency pair
     * @param opts.account Trading account
     */
    public async cancelSpotPriceTriggeredOrderList(opts: {
        market?: string;
        account?: 'normal' | 'margin';
    }): Promise<{ response: AxiosResponse; body: Array<SpotPriceTriggeredOrder> }> {
        const localVarPath = this.client.basePath + '/spot/price_orders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.market !== undefined) {
            localVarQueryParameters['market'] = ObjectSerializer.serialize(opts.market, 'string');
        }

        if (opts.account !== undefined) {
            localVarQueryParameters['account'] = ObjectSerializer.serialize(opts.account, "'normal' | 'margin'");
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SpotPriceTriggeredOrder>>(
            config,
            'Array<SpotPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Get a single order
     * @param orderId Retrieve the data of the order with the specified ID
     */
    public async getSpotPriceTriggeredOrder(
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: SpotPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/spot/price_orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error(
                'Required parameter orderId was null or undefined when calling getSpotPriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<SpotPriceTriggeredOrder>(config, 'SpotPriceTriggeredOrder', authSettings);
    }

    /**
     *
     * @summary Cancel a single order
     * @param orderId Retrieve the data of the order with the specified ID
     */
    public async cancelSpotPriceTriggeredOrder(
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: SpotPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/spot/price_orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error(
                'Required parameter orderId was null or undefined when calling cancelSpotPriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<SpotPriceTriggeredOrder>(config, 'SpotPriceTriggeredOrder', authSettings);
    }
}
