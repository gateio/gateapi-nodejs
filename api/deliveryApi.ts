/**
 * Gate API
 * Welcome to Gate API APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * Contact: support@mail.gate.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-locals */
import { DeliveryCandlestick } from '../model/deliveryCandlestick';
import { DeliveryContract } from '../model/deliveryContract';
import { DeliverySettlement } from '../model/deliverySettlement';
import { DeliveryTicker } from '../model/deliveryTicker';
import { FuturesAccount } from '../model/futuresAccount';
import { FuturesAccountBook } from '../model/futuresAccountBook';
import { FuturesLimitRiskTiers } from '../model/futuresLimitRiskTiers';
import { FuturesLiquidate } from '../model/futuresLiquidate';
import { FuturesOrder } from '../model/futuresOrder';
import { FuturesOrderBook } from '../model/futuresOrderBook';
import { FuturesPriceTriggeredOrder } from '../model/futuresPriceTriggeredOrder';
import { FuturesTrade } from '../model/futuresTrade';
import { InsuranceRecord } from '../model/insuranceRecord';
import { MyFuturesTrade } from '../model/myFuturesTrade';
import { Position } from '../model/position';
import { PositionClose } from '../model/positionClose';
import { TriggerOrderResponse } from '../model/triggerOrderResponse';
import { ObjectSerializer } from '../model/models';
import { ApiClient } from './apiClient';
import { AxiosRequestConfig, AxiosResponse } from 'axios';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class DeliveryApi {
    protected client: ApiClient;

    constructor(client?: ApiClient) {
        if (client) {
            this.client = client;
        } else {
            this.client = new ApiClient();
        }
    }

    /**
     *
     * @summary Query all futures contracts
     * @param settle Settle currency
     */
    public async listDeliveryContracts(
        settle: 'usdt',
    ): Promise<{ response: AxiosResponse; body: Array<DeliveryContract> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/contracts'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliveryContracts.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<DeliveryContract>>(config, 'Array<DeliveryContract>', authSettings);
    }

    /**
     *
     * @summary Query single contract information
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async getDeliveryContract(
        settle: 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: DeliveryContract }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/contracts/{contract}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getDeliveryContract.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getDeliveryContract.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<DeliveryContract>(config, 'DeliveryContract', authSettings);
    }

    /**
     * Bids will be sorted by price from high to low, while asks sorted reversely
     * @summary Query futures market depth information
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.interval Price precision for depth aggregation, 0 means no aggregation, defaults to 0 if not specified
     * @param opts.limit Number of depth levels
     * @param opts.withId Whether to return depth update ID. This ID increments by 1 each time depth changes
     */
    public async listDeliveryOrderBook(
        settle: 'usdt',
        contract: string,
        opts: { interval?: '0' | '0.1' | '0.01'; limit?: number; withId?: boolean },
    ): Promise<{ response: AxiosResponse; body: FuturesOrderBook }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/order_book'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliveryOrderBook.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listDeliveryOrderBook.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(opts.interval, "'0' | '0.1' | '0.01'");
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.withId !== undefined) {
            localVarQueryParameters['with_id'] = ObjectSerializer.serialize(opts.withId, 'boolean');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<FuturesOrderBook>(config, 'FuturesOrderBook', authSettings);
    }

    /**
     *
     * @summary Futures market transaction records
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.lastId 以上个列表的最后一条记录的 ID 作为下个列表的起点。 该字段不再继续支持，新的请求请使用 &#x60;from&#x60; 和 &#x60;to&#x60; 字段来限定时间范围
     * @param opts.from Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.
     * @param opts.to Specify end time in Unix seconds, default to current time.
     */
    public async listDeliveryTrades(
        settle: 'usdt',
        contract: string,
        opts: { limit?: number; lastId?: string; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesTrade> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/trades'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliveryTrades.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listDeliveryTrades.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.lastId !== undefined) {
            localVarQueryParameters['last_id'] = ObjectSerializer.serialize(opts.lastId, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesTrade>>(config, 'Array<FuturesTrade>', authSettings);
    }

    /**
     * Return specified contract candlesticks. If prefix `contract` with `mark_`, the contract\'s mark price candlesticks are returned; if prefix with `index_`, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying `from`, `to` and `interval`
     * @summary Futures market K-line chart
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified
     * @param opts.to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision
     * @param opts.limit Maximum number of recent data points to return. &#x60;limit&#x60; conflicts with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected.
     * @param opts.interval Time interval between data points, note that 1w represents a natural week, 7d time is aligned with Unix initial timeTime interval between data points, note that 1w represents a natural week, 7d time is aligned with Unix initial timeweek, 7d time is aligned with Unix initial time
     */
    public async listDeliveryCandlesticks(
        settle: 'usdt',
        contract: string,
        opts: {
            from?: number;
            to?: number;
            limit?: number;
            interval?:
                | '10s'
                | '30s'
                | '1m'
                | '5m'
                | '15m'
                | '30m'
                | '1h'
                | '2h'
                | '4h'
                | '6h'
                | '8h'
                | '12h'
                | '1d'
                | '7d'
                | '1w'
                | '30d';
        },
    ): Promise<{ response: AxiosResponse; body: Array<DeliveryCandlestick> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/candlesticks'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliveryCandlesticks.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listDeliveryCandlesticks.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(
                opts.interval,
                "'10s' | '30s' | '1m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '7d' | '1w' | '30d'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<DeliveryCandlestick>>(config, 'Array<DeliveryCandlestick>', authSettings);
    }

    /**
     *
     * @summary Get all futures trading statistics
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract
     */
    public async listDeliveryTickers(
        settle: 'usdt',
        opts: { contract?: string },
    ): Promise<{ response: AxiosResponse; body: Array<DeliveryTicker> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/tickers'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliveryTickers.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<DeliveryTicker>>(config, 'Array<DeliveryTicker>', authSettings);
    }

    /**
     *
     * @summary Futures market insurance fund history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in a single list
     */
    public async listDeliveryInsuranceLedger(
        settle: 'usdt',
        opts: { limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<InsuranceRecord> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/insurance'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling listDeliveryInsuranceLedger.',
            );
        }

        opts = opts || {};
        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<InsuranceRecord>>(config, 'Array<InsuranceRecord>', authSettings);
    }

    /**
     *
     * @summary Get futures account
     * @param settle Settle currency
     */
    public async listDeliveryAccounts(settle: 'usdt'): Promise<{ response: AxiosResponse; body: FuturesAccount }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/accounts'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliveryAccounts.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesAccount>(config, 'FuturesAccount', authSettings);
    }

    /**
     *
     * @summary Query futures account change history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     * @param opts.type Changing Type: - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: point_fee: POINT Trading fee - point_refr: POINT Referrer rebate
     */
    public async listDeliveryAccountBook(
        settle: 'usdt',
        opts: {
            limit?: number;
            from?: number;
            to?: number;
            type?: 'dnw' | 'pnl' | 'fee' | 'refr' | 'fund' | 'point_dnw' | 'point_fee' | 'point_refr';
        },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesAccountBook> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/account_book'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliveryAccountBook.');
        }

        opts = opts || {};
        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(
                opts.type,
                "'dnw' | 'pnl' | 'fee' | 'refr' | 'fund' | 'point_dnw' | 'point_fee' | 'point_refr'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesAccountBook>>(config, 'Array<FuturesAccountBook>', authSettings);
    }

    /**
     *
     * @summary Get user position list
     * @param settle Settle currency
     */
    public async listDeliveryPositions(settle: 'usdt'): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/positions'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliveryPositions.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     *
     * @summary Get single position information
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async getDeliveryPosition(
        settle: 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/positions/{contract}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getDeliveryPosition.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getDeliveryPosition.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *
     * @summary Update position margin
     * @param settle Settle currency
     * @param contract Futures contract
     * @param change Margin change amount, positive number increases, negative number decreases
     */
    public async updateDeliveryPositionMargin(
        settle: 'usdt',
        contract: string,
        change: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/positions/{contract}/margin'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDeliveryPositionMargin.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateDeliveryPositionMargin.',
            );
        }

        // verify required parameter 'change' is not null or undefined
        if (change === null || change === undefined) {
            throw new Error(
                'Required parameter change was null or undefined when calling updateDeliveryPositionMargin.',
            );
        }

        localVarQueryParameters['change'] = ObjectSerializer.serialize(change, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *
     * @summary Update position leverage
     * @param settle Settle currency
     * @param contract Futures contract
     * @param leverage New position leverage
     */
    public async updateDeliveryPositionLeverage(
        settle: 'usdt',
        contract: string,
        leverage: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/positions/{contract}/leverage'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDeliveryPositionLeverage.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateDeliveryPositionLeverage.',
            );
        }

        // verify required parameter 'leverage' is not null or undefined
        if (leverage === null || leverage === undefined) {
            throw new Error(
                'Required parameter leverage was null or undefined when calling updateDeliveryPositionLeverage.',
            );
        }

        localVarQueryParameters['leverage'] = ObjectSerializer.serialize(leverage, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *
     * @summary Update position risk limit
     * @param settle Settle currency
     * @param contract Futures contract
     * @param riskLimit New position risk limit
     */
    public async updateDeliveryPositionRiskLimit(
        settle: 'usdt',
        contract: string,
        riskLimit: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/positions/{contract}/risk_limit'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDeliveryPositionRiskLimit.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateDeliveryPositionRiskLimit.',
            );
        }

        // verify required parameter 'riskLimit' is not null or undefined
        if (riskLimit === null || riskLimit === undefined) {
            throw new Error(
                'Required parameter riskLimit was null or undefined when calling updateDeliveryPositionRiskLimit.',
            );
        }

        localVarQueryParameters['risk_limit'] = ObjectSerializer.serialize(riskLimit, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     * Zero-fill orders cannot be retrieved 10 minutes after order cancellation
     * @summary Query futures order list
     * @param settle Settle currency
     * @param status Query order list based on status
     * @param opts Optional parameters
     * @param opts.contract Futures contract
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.lastId Specify the currency name to query in batches, and support up to 100 pass parameters at a time
     * @param opts.countTotal Whether to return total number matched, defaults to 0 (no return)
     */
    public async listDeliveryOrders(
        settle: 'usdt',
        status: 'open' | 'finished',
        opts: { contract?: string; limit?: number; offset?: number; lastId?: string; countTotal?: 0 | 1 },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliveryOrders.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling listDeliveryOrders.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'open' | 'finished'");

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.lastId !== undefined) {
            localVarQueryParameters['last_id'] = ObjectSerializer.serialize(opts.lastId, 'string');
        }

        if (opts.countTotal !== undefined) {
            localVarQueryParameters['count_total'] = ObjectSerializer.serialize(opts.countTotal, '0 | 1');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesOrder>>(config, 'Array<FuturesOrder>', authSettings);
    }

    /**
     * Zero-fill orders cannot be retrieved 10 minutes after order cancellation
     * @summary Place futures order
     * @param settle Settle currency
     * @param futuresOrder
     */
    public async createDeliveryOrder(
        settle: 'usdt',
        futuresOrder: FuturesOrder,
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling createDeliveryOrder.');
        }

        // verify required parameter 'futuresOrder' is not null or undefined
        if (futuresOrder === null || futuresOrder === undefined) {
            throw new Error('Required parameter futuresOrder was null or undefined when calling createDeliveryOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresOrder, 'FuturesOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     * Zero-fill orders cannot be retrieved 10 minutes after order cancellation
     * @summary Cancel all orders with \'open\' status
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.side Specify all bids or all asks, both included if not specified
     */
    public async cancelDeliveryOrders(
        settle: 'usdt',
        contract: string,
        opts: { side?: 'ask' | 'bid' },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelDeliveryOrders.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling cancelDeliveryOrders.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.side !== undefined) {
            localVarQueryParameters['side'] = ObjectSerializer.serialize(opts.side, "'ask' | 'bid'");
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesOrder>>(config, 'Array<FuturesOrder>', authSettings);
    }

    /**
     * Zero-fill orders cannot be retrieved 10 minutes after order cancellation
     * @summary Query single order details
     * @param settle Settle currency
     * @param orderId ID returned when order is successfully created
     */
    public async getDeliveryOrder(
        settle: 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getDeliveryOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getDeliveryOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     *
     * @summary Cancel single order
     * @param settle Settle currency
     * @param orderId ID returned when order is successfully created
     */
    public async cancelDeliveryOrder(
        settle: 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelDeliveryOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelDeliveryOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     *
     * @summary Query personal trading records
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract
     * @param opts.order Futures order ID, return related data only if specified
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.lastId Specify the currency name to query in batches, and support up to 100 pass parameters at a time
     * @param opts.countTotal Whether to return total number matched, defaults to 0 (no return)
     */
    public async getMyDeliveryTrades(
        settle: 'usdt',
        opts: {
            contract?: string;
            order?: number;
            limit?: number;
            offset?: number;
            lastId?: string;
            countTotal?: 0 | 1;
        },
    ): Promise<{ response: AxiosResponse; body: Array<MyFuturesTrade> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/my_trades'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getMyDeliveryTrades.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(opts.order, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.lastId !== undefined) {
            localVarQueryParameters['last_id'] = ObjectSerializer.serialize(opts.lastId, 'string');
        }

        if (opts.countTotal !== undefined) {
            localVarQueryParameters['count_total'] = ObjectSerializer.serialize(opts.countTotal, '0 | 1');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<MyFuturesTrade>>(config, 'Array<MyFuturesTrade>', authSettings);
    }

    /**
     *
     * @summary Query position close history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract
     * @param opts.limit Maximum number of records returned in a single list
     */
    public async listDeliveryPositionClose(
        settle: 'usdt',
        opts: { contract?: string; limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<PositionClose> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/position_close'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliveryPositionClose.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<PositionClose>>(config, 'Array<PositionClose>', authSettings);
    }

    /**
     *
     * @summary Query liquidation history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.at Specify liquidation timestamp
     */
    public async listDeliveryLiquidates(
        settle: 'usdt',
        opts: { contract?: string; limit?: number; at?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesLiquidate> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/liquidates'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliveryLiquidates.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.at !== undefined) {
            localVarQueryParameters['at'] = ObjectSerializer.serialize(opts.at, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesLiquidate>>(config, 'Array<FuturesLiquidate>', authSettings);
    }

    /**
     *
     * @summary Query settlement records
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.at Specify settlement timestamp
     */
    public async listDeliverySettlements(
        settle: 'usdt',
        opts: { contract?: string; limit?: number; at?: number },
    ): Promise<{ response: AxiosResponse; body: Array<DeliverySettlement> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/settlements'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliverySettlements.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.at !== undefined) {
            localVarQueryParameters['at'] = ObjectSerializer.serialize(opts.at, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<DeliverySettlement>>(config, 'Array<DeliverySettlement>', authSettings);
    }

    /**
     * When the \'contract\' parameter is not passed, the default is to query the risk limits for the top 100 markets.\'Limit\' and \'offset\' correspond to pagination queries at the market level, not to the length of the returned array. This only takes effect empty.
     * @summary Query risk limit tiers
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listDeliveryRiskLimitTiers(
        settle: 'usdt',
        opts: { contract?: string; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesLimitRiskTiers> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/risk_limit_tiers'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listDeliveryRiskLimitTiers.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesLimitRiskTiers>>(config, 'Array<FuturesLimitRiskTiers>', authSettings);
    }

    /**
     *
     * @summary Query auto order list
     * @param settle Settle currency
     * @param status Query order list based on status
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listPriceTriggeredDeliveryOrders(
        settle: 'usdt',
        status: 'open' | 'finished',
        opts: { contract?: string; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesPriceTriggeredOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/price_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling listPriceTriggeredDeliveryOrders.',
            );
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error(
                'Required parameter status was null or undefined when calling listPriceTriggeredDeliveryOrders.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'open' | 'finished'");

        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesPriceTriggeredOrder>>(
            config,
            'Array<FuturesPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Create price-triggered order
     * @param settle Settle currency
     * @param futuresPriceTriggeredOrder
     */
    public async createPriceTriggeredDeliveryOrder(
        settle: 'usdt',
        futuresPriceTriggeredOrder: FuturesPriceTriggeredOrder,
    ): Promise<{ response: AxiosResponse; body: TriggerOrderResponse }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/price_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling createPriceTriggeredDeliveryOrder.',
            );
        }

        // verify required parameter 'futuresPriceTriggeredOrder' is not null or undefined
        if (futuresPriceTriggeredOrder === null || futuresPriceTriggeredOrder === undefined) {
            throw new Error(
                'Required parameter futuresPriceTriggeredOrder was null or undefined when calling createPriceTriggeredDeliveryOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresPriceTriggeredOrder, 'FuturesPriceTriggeredOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerOrderResponse>(config, 'TriggerOrderResponse', authSettings);
    }

    /**
     *
     * @summary Cancel all auto orders
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async cancelPriceTriggeredDeliveryOrderList(
        settle: 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: Array<FuturesPriceTriggeredOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/price_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling cancelPriceTriggeredDeliveryOrderList.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling cancelPriceTriggeredDeliveryOrderList.',
            );
        }

        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesPriceTriggeredOrder>>(
            config,
            'Array<FuturesPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Query single auto order details
     * @param settle Settle currency
     * @param orderId ID returned when order is successfully created
     */
    public async getPriceTriggeredDeliveryOrder(
        settle: 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/price_orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling getPriceTriggeredDeliveryOrder.',
            );
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error(
                'Required parameter orderId was null or undefined when calling getPriceTriggeredDeliveryOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesPriceTriggeredOrder>(config, 'FuturesPriceTriggeredOrder', authSettings);
    }

    /**
     *
     * @summary Cancel single auto order
     * @param settle Settle currency
     * @param orderId ID returned when order is successfully created
     */
    public async cancelPriceTriggeredDeliveryOrder(
        settle: 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/delivery/{settle}/price_orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling cancelPriceTriggeredDeliveryOrder.',
            );
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error(
                'Required parameter orderId was null or undefined when calling cancelPriceTriggeredDeliveryOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesPriceTriggeredOrder>(config, 'FuturesPriceTriggeredOrder', authSettings);
    }
}
