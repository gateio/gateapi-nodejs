/**
 * Gate API v4
 * Welcome to Gate.io API  APIv4 provides spot, margin and futures trading operations. There are public APIs to retrieve the real-time market statistics, and private APIs which needs authentication to trade on user\'s behalf.
 *
 * Contact: support@mail.gate.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-locals */
import { BatchAmendOrderReq } from '../model/batchAmendOrderReq';
import { BatchFuturesOrder } from '../model/batchFuturesOrder';
import { Contract } from '../model/contract';
import { ContractStat } from '../model/contractStat';
import { CountdownCancelAllFuturesTask } from '../model/countdownCancelAllFuturesTask';
import { FundingRateRecord } from '../model/fundingRateRecord';
import { FutureCancelOrderResult } from '../model/futureCancelOrderResult';
import { FuturesAccount } from '../model/futuresAccount';
import { FuturesAccountBook } from '../model/futuresAccountBook';
import { FuturesAutoDeleverage } from '../model/futuresAutoDeleverage';
import { FuturesCandlestick } from '../model/futuresCandlestick';
import { FuturesFee } from '../model/futuresFee';
import { FuturesIndexConstituents } from '../model/futuresIndexConstituents';
import { FuturesLimitRiskTiers } from '../model/futuresLimitRiskTiers';
import { FuturesLiqOrder } from '../model/futuresLiqOrder';
import { FuturesLiquidate } from '../model/futuresLiquidate';
import { FuturesOrder } from '../model/futuresOrder';
import { FuturesOrderAmendment } from '../model/futuresOrderAmendment';
import { FuturesOrderBook } from '../model/futuresOrderBook';
import { FuturesPremiumIndex } from '../model/futuresPremiumIndex';
import { FuturesPriceTriggeredOrder } from '../model/futuresPriceTriggeredOrder';
import { FuturesTicker } from '../model/futuresTicker';
import { FuturesTrade } from '../model/futuresTrade';
import { InlineObject } from '../model/inlineObject';
import { InsuranceRecord } from '../model/insuranceRecord';
import { MyFuturesTrade } from '../model/myFuturesTrade';
import { MyFuturesTradeTimeRange } from '../model/myFuturesTradeTimeRange';
import { Position } from '../model/position';
import { PositionClose } from '../model/positionClose';
import { TriggerOrderResponse } from '../model/triggerOrderResponse';
import { TriggerTime } from '../model/triggerTime';
import { ObjectSerializer } from '../model/models';
import { ApiClient } from './apiClient';
import { AxiosRequestConfig, AxiosResponse } from 'axios';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class FuturesApi {
    protected client: ApiClient;

    constructor(client?: ApiClient) {
        if (client) {
            this.client = client;
        } else {
            this.client = new ApiClient();
        }
    }

    /**
     *
     * @summary List all futures contracts
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listFuturesContracts(
        settle: 'btc' | 'usdt',
        opts: { limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<Contract> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/contracts'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesContracts.');
        }

        opts = opts || {};
        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Contract>>(config, 'Array<Contract>', authSettings);
    }

    /**
     *
     * @summary Get a single contract
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async getFuturesContract(
        settle: 'btc' | 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: Contract }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/contracts/{contract}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getFuturesContract.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getFuturesContract.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Contract>(config, 'Contract', authSettings);
    }

    /**
     * Bids will be sorted by price from high to low, while asks sorted reversely
     * @summary Futures order book
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.interval Order depth. 0 means no aggregation is applied. default to 0
     * @param opts.limit Maximum number of order depth data in asks or bids
     * @param opts.withId Whether the order book update ID will be returned. This ID increases by 1 on every order book update
     */
    public async listFuturesOrderBook(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { interval?: string; limit?: number; withId?: boolean },
    ): Promise<{ response: AxiosResponse; body: FuturesOrderBook }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/order_book'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesOrderBook.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listFuturesOrderBook.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(opts.interval, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.withId !== undefined) {
            localVarQueryParameters['with_id'] = ObjectSerializer.serialize(opts.withId, 'boolean');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<FuturesOrderBook>(config, 'FuturesOrderBook', authSettings);
    }

    /**
     *
     * @summary Futures trading history
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.lastId Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range
     * @param opts.from Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.
     * @param opts.to Specify end time in Unix seconds, default to current time
     */
    public async listFuturesTrades(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { limit?: number; offset?: number; lastId?: string; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesTrade> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/trades'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesTrades.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listFuturesTrades.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.lastId !== undefined) {
            localVarQueryParameters['last_id'] = ObjectSerializer.serialize(opts.lastId, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesTrade>>(config, 'Array<FuturesTrade>', authSettings);
    }

    /**
     * Return specified contract candlesticks. If prefix `contract` with `mark_`, the contract\'s mark price candlesticks are returned; if prefix with `index_`, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying `from`, `to` and `interval`
     * @summary Get futures candlesticks
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified
     * @param opts.to End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time
     * @param opts.limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected.
     * @param opts.interval Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0.  Note that 30d means 1 natual month, not 30 days
     */
    public async listFuturesCandlesticks(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { from?: number; to?: number; limit?: number; interval?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesCandlestick> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/candlesticks'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesCandlesticks.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listFuturesCandlesticks.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(opts.interval, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesCandlestick>>(config, 'Array<FuturesCandlestick>', authSettings);
    }

    /**
     * Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
     * @summary Premium Index K-Line
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified
     * @param opts.to End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time
     * @param opts.limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected.
     * @param opts.interval Interval time between data points
     */
    public async listFuturesPremiumIndex(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { from?: number; to?: number; limit?: number; interval?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesPremiumIndex> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/premium_index'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesPremiumIndex.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listFuturesPremiumIndex.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(opts.interval, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesPremiumIndex>>(config, 'Array<FuturesPremiumIndex>', authSettings);
    }

    /**
     *
     * @summary List futures tickers
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     */
    public async listFuturesTickers(
        settle: 'btc' | 'usdt',
        opts: { contract?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesTicker> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/tickers'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesTickers.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesTicker>>(config, 'Array<FuturesTicker>', authSettings);
    }

    /**
     *
     * @summary Funding rate history
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     */
    public async listFuturesFundingRateHistory(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { limit?: number; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FundingRateRecord> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/funding_rate'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling listFuturesFundingRateHistory.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling listFuturesFundingRateHistory.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FundingRateRecord>>(config, 'Array<FundingRateRecord>', authSettings);
    }

    /**
     *
     * @summary Futures insurance balance history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records to be returned in a single list
     */
    public async listFuturesInsuranceLedger(
        settle: 'btc' | 'usdt',
        opts: { limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<InsuranceRecord> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/insurance'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesInsuranceLedger.');
        }

        opts = opts || {};
        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<InsuranceRecord>>(config, 'Array<InsuranceRecord>', authSettings);
    }

    /**
     *
     * @summary Futures stats
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.from Start timestamp
     * @param opts.interval
     * @param opts.limit
     */
    public async listContractStats(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { from?: number; interval?: string; limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<ContractStat> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/contract_stats'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listContractStats.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listContractStats.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(opts.interval, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<ContractStat>>(config, 'Array<ContractStat>', authSettings);
    }

    /**
     *
     * @summary Get index constituents
     * @param settle Settle currency
     * @param index Index name
     */
    public async getIndexConstituents(
        settle: 'btc' | 'usdt',
        index: string,
    ): Promise<{ response: AxiosResponse; body: FuturesIndexConstituents }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/index_constituents/{index}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getIndexConstituents.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling getIndexConstituents.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<FuturesIndexConstituents>(config, 'FuturesIndexConstituents', authSettings);
    }

    /**
     * Interval between `from` and `to` cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
     * @summary Retrieve liquidation history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     * @param opts.limit Maximum number of records to be returned in a single list
     */
    public async listLiquidatedOrders(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; from?: number; to?: number; limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesLiqOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/liq_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listLiquidatedOrders.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesLiqOrder>>(config, 'Array<FuturesLiqOrder>', authSettings);
    }

    /**
     * When the \'contract\' parameter is not passed, the default is to query the risk limits for the top 100 markets.\'Limit\' and \'offset\' correspond to pagination queries at the market level, not to the length of the returned array. This only takes effect when the \'contract\' parameter is empty.
     * @summary List risk limit tiers
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listFuturesRiskLimitTiers(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesLimitRiskTiers> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/risk_limit_tiers'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesRiskLimitTiers.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesLimitRiskTiers>>(config, 'Array<FuturesLimitRiskTiers>', authSettings);
    }

    /**
     *
     * @summary Query futures account
     * @param settle Settle currency
     */
    public async listFuturesAccounts(
        settle: 'btc' | 'usdt',
    ): Promise<{ response: AxiosResponse; body: FuturesAccount }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/accounts'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesAccounts.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesAccount>(config, 'FuturesAccount', authSettings);
    }

    /**
     * If the `contract` field is provided, it can only filter records that include this field after 2023-10-30.
     * @summary Query account book
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     * @param opts.type Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction
     */
    public async listFuturesAccountBook(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; limit?: number; offset?: number; from?: number; to?: number; type?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesAccountBook> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/account_book'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesAccountBook.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(opts.type, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesAccountBook>>(config, 'Array<FuturesAccountBook>', authSettings);
    }

    /**
     *
     * @summary List all positions of a user
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.holding Return only real positions - true, return all - false.
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listPositions(
        settle: 'btc' | 'usdt',
        opts: { holding?: boolean; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listPositions.');
        }

        opts = opts || {};
        if (opts.holding !== undefined) {
            localVarQueryParameters['holding'] = ObjectSerializer.serialize(opts.holding, 'boolean');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     *
     * @summary Get single position
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async getPosition(
        settle: 'btc' | 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getPosition.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getPosition.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *
     * @summary Update position margin
     * @param settle Settle currency
     * @param contract Futures contract
     * @param change Margin change. Use positive number to increase margin, negative number otherwise.
     */
    public async updatePositionMargin(
        settle: 'btc' | 'usdt',
        contract: string,
        change: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}/margin'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling updatePositionMargin.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling updatePositionMargin.');
        }

        // verify required parameter 'change' is not null or undefined
        if (change === null || change === undefined) {
            throw new Error('Required parameter change was null or undefined when calling updatePositionMargin.');
        }

        localVarQueryParameters['change'] = ObjectSerializer.serialize(change, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *
     * @summary Update position leverage
     * @param settle Settle currency
     * @param contract Futures contract
     * @param leverage New position leverage
     * @param opts Optional parameters
     * @param opts.crossLeverageLimit Cross margin leverage(valid only when &#x60;leverage&#x60; is 0)
     */
    public async updatePositionLeverage(
        settle: 'btc' | 'usdt',
        contract: string,
        leverage: string,
        opts: { crossLeverageLimit?: string },
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}/leverage'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling updatePositionLeverage.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling updatePositionLeverage.');
        }

        // verify required parameter 'leverage' is not null or undefined
        if (leverage === null || leverage === undefined) {
            throw new Error('Required parameter leverage was null or undefined when calling updatePositionLeverage.');
        }

        opts = opts || {};
        localVarQueryParameters['leverage'] = ObjectSerializer.serialize(leverage, 'string');

        if (opts.crossLeverageLimit !== undefined) {
            localVarQueryParameters['cross_leverage_limit'] = ObjectSerializer.serialize(
                opts.crossLeverageLimit,
                'string',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *
     * @summary Switch to the full position-by-store mode
     * @param settle Settle currency
     * @param inlineObject
     */
    public async updatePositionCrossMode(
        settle: 'btc' | 'usdt',
        inlineObject: InlineObject,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/cross_mode'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling updatePositionCrossMode.');
        }

        // verify required parameter 'inlineObject' is not null or undefined
        if (inlineObject === null || inlineObject === undefined) {
            throw new Error(
                'Required parameter inlineObject was null or undefined when calling updatePositionCrossMode.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(inlineObject, 'InlineObject'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *
     * @summary Update position risk limit
     * @param settle Settle currency
     * @param contract Futures contract
     * @param riskLimit New Risk Limit Value
     */
    public async updatePositionRiskLimit(
        settle: 'btc' | 'usdt',
        contract: string,
        riskLimit: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}/risk_limit'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling updatePositionRiskLimit.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling updatePositionRiskLimit.');
        }

        // verify required parameter 'riskLimit' is not null or undefined
        if (riskLimit === null || riskLimit === undefined) {
            throw new Error('Required parameter riskLimit was null or undefined when calling updatePositionRiskLimit.');
        }

        localVarQueryParameters['risk_limit'] = ObjectSerializer.serialize(riskLimit, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     * Before setting dual mode, make sure all positions are closed and no orders are open
     * @summary Enable or disable dual mode
     * @param settle Settle currency
     * @param dualMode Whether to enable dual mode
     */
    public async setDualMode(
        settle: 'btc' | 'usdt',
        dualMode: boolean,
    ): Promise<{ response: AxiosResponse; body: FuturesAccount }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_mode'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling setDualMode.');
        }

        // verify required parameter 'dualMode' is not null or undefined
        if (dualMode === null || dualMode === undefined) {
            throw new Error('Required parameter dualMode was null or undefined when calling setDualMode.');
        }

        localVarQueryParameters['dual_mode'] = ObjectSerializer.serialize(dualMode, 'boolean');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesAccount>(config, 'FuturesAccount', authSettings);
    }

    /**
     *
     * @summary Retrieve position detail in dual mode
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async getDualModePosition(
        settle: 'btc' | 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/{contract}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getDualModePosition.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getDualModePosition.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     *
     * @summary Update position margin in dual mode
     * @param settle Settle currency
     * @param contract Futures contract
     * @param change Margin change. Use positive number to increase margin, negative number otherwise.
     * @param dualSide Long or short position
     */
    public async updateDualModePositionMargin(
        settle: 'btc' | 'usdt',
        contract: string,
        change: string,
        dualSide: string,
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/{contract}/margin'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDualModePositionMargin.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateDualModePositionMargin.',
            );
        }

        // verify required parameter 'change' is not null or undefined
        if (change === null || change === undefined) {
            throw new Error(
                'Required parameter change was null or undefined when calling updateDualModePositionMargin.',
            );
        }

        // verify required parameter 'dualSide' is not null or undefined
        if (dualSide === null || dualSide === undefined) {
            throw new Error(
                'Required parameter dualSide was null or undefined when calling updateDualModePositionMargin.',
            );
        }

        localVarQueryParameters['change'] = ObjectSerializer.serialize(change, 'string');

        localVarQueryParameters['dual_side'] = ObjectSerializer.serialize(dualSide, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     *
     * @summary Update position leverage in dual mode
     * @param settle Settle currency
     * @param contract Futures contract
     * @param leverage New position leverage
     * @param opts Optional parameters
     * @param opts.crossLeverageLimit Cross margin leverage(valid only when &#x60;leverage&#x60; is 0)
     */
    public async updateDualModePositionLeverage(
        settle: 'btc' | 'usdt',
        contract: string,
        leverage: string,
        opts: { crossLeverageLimit?: string },
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/{contract}/leverage'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDualModePositionLeverage.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateDualModePositionLeverage.',
            );
        }

        // verify required parameter 'leverage' is not null or undefined
        if (leverage === null || leverage === undefined) {
            throw new Error(
                'Required parameter leverage was null or undefined when calling updateDualModePositionLeverage.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['leverage'] = ObjectSerializer.serialize(leverage, 'string');

        if (opts.crossLeverageLimit !== undefined) {
            localVarQueryParameters['cross_leverage_limit'] = ObjectSerializer.serialize(
                opts.crossLeverageLimit,
                'string',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     *
     * @summary Update position risk limit in dual mode
     * @param settle Settle currency
     * @param contract Futures contract
     * @param riskLimit New Risk Limit Value
     */
    public async updateDualModePositionRiskLimit(
        settle: 'btc' | 'usdt',
        contract: string,
        riskLimit: string,
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/{contract}/risk_limit'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDualModePositionRiskLimit.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateDualModePositionRiskLimit.',
            );
        }

        // verify required parameter 'riskLimit' is not null or undefined
        if (riskLimit === null || riskLimit === undefined) {
            throw new Error(
                'Required parameter riskLimit was null or undefined when calling updateDualModePositionRiskLimit.',
            );
        }

        localVarQueryParameters['risk_limit'] = ObjectSerializer.serialize(riskLimit, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     * - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use `GET /futures/{settle}/orders_timerange`.
     * @summary List futures orders
     * @param settle Settle currency
     * @param status Only list the orders with this status
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.lastId Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results
     */
    public async listFuturesOrders(
        settle: 'btc' | 'usdt',
        status: string,
        opts: { contract?: string; limit?: number; offset?: number; lastId?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesOrders.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling listFuturesOrders.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.lastId !== undefined) {
            localVarQueryParameters['last_id'] = ObjectSerializer.serialize(opts.lastId, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesOrder>>(config, 'Array<FuturesOrder>', authSettings);
    }

    /**
     * - When placing an order, the number of contracts is specified `size`, not the number of coins. The number of coins corresponding to each contract is returned in the contract details interface `quanto_multiplier` - 0 The order that was completed cannot be obtained after 10 minutes of withdrawal, and the order will be mentioned that the order does not exist - Setting `reduce_only` to `true` can prevent the position from being penetrated when reducing the position - In single-position mode, if you need to close the position, you need to set `size` to 0 and `close` to `true` - In dual warehouse mode,   - Reduce position: reduce_only=true, size is a positive number that indicates short position, negative number that indicates long position  - Add position: reduce_only=false, size is a positive number that indicates adding long positions, and negative numbers indicate adding short positions  - Close position: size=0, set the direction of closing position according to auto_size, and set `reduce_only` to true  at the same time - reduce_only: Make sure to only perform position reduction operations to prevent increased positions - Set `stp_act` to determine the use of a strategy that restricts user transactions. For detailed usage, refer to the body parameter `stp_act`
     * @summary Create a futures order
     * @param settle Settle currency
     * @param futuresOrder
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async createFuturesOrder(
        settle: 'btc' | 'usdt',
        futuresOrder: FuturesOrder,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling createFuturesOrder.');
        }

        // verify required parameter 'futuresOrder' is not null or undefined
        if (futuresOrder === null || futuresOrder === undefined) {
            throw new Error('Required parameter futuresOrder was null or undefined when calling createFuturesOrder.');
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresOrder, 'FuturesOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     * Zero-filled order cannot be retrieved 10 minutes after order cancellation
     * @summary Cancel all `open` orders matched
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     * @param opts.side Specify all buy orders or all sell orders, if not specify them, both are included. Revoke all buy orders and revoke all sell orders and make ask
     */
    public async cancelFuturesOrders(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { xGateExptime?: string; side?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelFuturesOrders.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling cancelFuturesOrders.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.side !== undefined) {
            localVarQueryParameters['side'] = ObjectSerializer.serialize(opts.side, 'string');
        }

        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesOrder>>(config, 'Array<FuturesOrder>', authSettings);
    }

    /**
     *
     * @summary List Futures Orders By Time Range
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async getOrdersWithTimeRange(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; from?: number; to?: number; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders_timerange'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getOrdersWithTimeRange.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesOrder>>(config, 'Array<FuturesOrder>', authSettings);
    }

    /**
     * - Up to 10 orders per request - If any of the order\'s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the `succeeded` field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the `label` field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
     * @summary Create a batch of futures orders
     * @param settle Settle currency
     * @param futuresOrder
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async createBatchFuturesOrder(
        settle: 'btc' | 'usdt',
        futuresOrder: Array<FuturesOrder>,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: Array<BatchFuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/batch_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling createBatchFuturesOrder.');
        }

        // verify required parameter 'futuresOrder' is not null or undefined
        if (futuresOrder === null || futuresOrder === undefined) {
            throw new Error(
                'Required parameter futuresOrder was null or undefined when calling createBatchFuturesOrder.',
            );
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresOrder, 'Array<FuturesOrder>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<BatchFuturesOrder>>(config, 'Array<BatchFuturesOrder>', authSettings);
    }

    /**
     * - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.
     * @summary Get a single order
     * @param settle Settle currency
     * @param orderId Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.
     */
    public async getFuturesOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getFuturesOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getFuturesOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     *
     * @summary Amend an order
     * @param settle Settle currency
     * @param orderId Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.
     * @param futuresOrderAmendment
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async amendFuturesOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
        futuresOrderAmendment: FuturesOrderAmendment,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling amendFuturesOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling amendFuturesOrder.');
        }

        // verify required parameter 'futuresOrderAmendment' is not null or undefined
        if (futuresOrderAmendment === null || futuresOrderAmendment === undefined) {
            throw new Error(
                'Required parameter futuresOrderAmendment was null or undefined when calling amendFuturesOrder.',
            );
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresOrderAmendment, 'FuturesOrderAmendment'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     *
     * @summary Cancel a single order
     * @param settle Settle currency
     * @param orderId Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async cancelFuturesOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelFuturesOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelFuturesOrder.');
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     * By default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use `GET /futures/{settle}/my_trades_timerange`.
     * @summary List personal trading history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.order Futures order ID, return related data only if specified
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.lastId Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using \&#39;GET /futures/{settle}/my_trades_timerange\&#39;.
     */
    public async getMyTrades(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; order?: number; limit?: number; offset?: number; lastId?: string },
    ): Promise<{ response: AxiosResponse; body: Array<MyFuturesTrade> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/my_trades'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getMyTrades.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(opts.order, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.lastId !== undefined) {
            localVarQueryParameters['last_id'] = ObjectSerializer.serialize(opts.lastId, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<MyFuturesTrade>>(config, 'Array<MyFuturesTrade>', authSettings);
    }

    /**
     *
     * @summary List personal trading history by time range
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.role Query role, maker or taker.
     */
    public async getMyTradesWithTimeRange(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; from?: number; to?: number; limit?: number; offset?: number; role?: string },
    ): Promise<{ response: AxiosResponse; body: Array<MyFuturesTradeTimeRange> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/my_trades_timerange'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getMyTradesWithTimeRange.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(opts.role, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<MyFuturesTradeTimeRange>>(
            config,
            'Array<MyFuturesTradeTimeRange>',
            authSettings,
        );
    }

    /**
     *
     * @summary List position close history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     * @param opts.side Query side.  long or shot
     * @param opts.pnl Query profit or loss
     */
    public async listPositionClose(
        settle: 'btc' | 'usdt',
        opts: {
            contract?: string;
            limit?: number;
            offset?: number;
            from?: number;
            to?: number;
            side?: string;
            pnl?: string;
        },
    ): Promise<{ response: AxiosResponse; body: Array<PositionClose> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/position_close'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listPositionClose.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.side !== undefined) {
            localVarQueryParameters['side'] = ObjectSerializer.serialize(opts.side, 'string');
        }

        if (opts.pnl !== undefined) {
            localVarQueryParameters['pnl'] = ObjectSerializer.serialize(opts.pnl, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<PositionClose>>(config, 'Array<PositionClose>', authSettings);
    }

    /**
     *
     * @summary List liquidation history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.at Specify a liquidation timestamp
     */
    public async listLiquidates(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; limit?: number; at?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesLiquidate> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/liquidates'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listLiquidates.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.at !== undefined) {
            localVarQueryParameters['at'] = ObjectSerializer.serialize(opts.at, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesLiquidate>>(config, 'Array<FuturesLiquidate>', authSettings);
    }

    /**
     *
     * @summary List Auto-Deleveraging History
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.at Specify an auto-deleveraging timestamp
     */
    public async listAutoDeleverages(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; limit?: number; at?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesAutoDeleverage> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/auto_deleverages'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listAutoDeleverages.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.at !== undefined) {
            localVarQueryParameters['at'] = ObjectSerializer.serialize(opts.at, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesAutoDeleverage>>(config, 'Array<FuturesAutoDeleverage>', authSettings);
    }

    /**
     * When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown`timeout` is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified `market` will be automatically cancelled, if no `market` is specified, all market pending orders will be cancelled. If the `timeout` is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
     * @summary Countdown cancel orders
     * @param settle Settle currency
     * @param countdownCancelAllFuturesTask
     */
    public async countdownCancelAllFutures(
        settle: 'btc' | 'usdt',
        countdownCancelAllFuturesTask: CountdownCancelAllFuturesTask,
    ): Promise<{ response: AxiosResponse; body: TriggerTime }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/countdown_cancel_all'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling countdownCancelAllFutures.');
        }

        // verify required parameter 'countdownCancelAllFuturesTask' is not null or undefined
        if (countdownCancelAllFuturesTask === null || countdownCancelAllFuturesTask === undefined) {
            throw new Error(
                'Required parameter countdownCancelAllFuturesTask was null or undefined when calling countdownCancelAllFutures.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(countdownCancelAllFuturesTask, 'CountdownCancelAllFuturesTask'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerTime>(config, 'TriggerTime', authSettings);
    }

    /**
     *
     * @summary Query user trading fee rates
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     */
    public async getFuturesFee(
        settle: 'btc' | 'usdt',
        opts: { contract?: string },
    ): Promise<{ response: AxiosResponse; body: { [key: string]: FuturesFee } }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/fee'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getFuturesFee.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<{ [key: string]: FuturesFee }>(
            config,
            '{ [key: string]: FuturesFee; }',
            authSettings,
        );
    }

    /**
     * Multiple distinct order ID list can be specified。Each request can cancel a maximum of 20 records.
     * @summary Cancel a batch of orders with an ID list
     * @param settle Settle currency
     * @param requestBody
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async cancelBatchFutureOrders(
        settle: 'btc' | 'usdt',
        requestBody: Array<string>,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FutureCancelOrderResult> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/batch_cancel_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelBatchFutureOrders.');
        }

        // verify required parameter 'requestBody' is not null or undefined
        if (requestBody === null || requestBody === undefined) {
            throw new Error(
                'Required parameter requestBody was null or undefined when calling cancelBatchFutureOrders.',
            );
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(requestBody, 'Array<string>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FutureCancelOrderResult>>(
            config,
            'Array<FutureCancelOrderResult>',
            authSettings,
        );
    }

    /**
     * You can specify multiple different order IDs. You can only modify up to 10 orders in one request.
     * @summary Batch modify orders with specified IDs
     * @param settle Settle currency
     * @param batchAmendOrderReq
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async amendBatchFutureOrders(
        settle: 'btc' | 'usdt',
        batchAmendOrderReq: Array<BatchAmendOrderReq>,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: Array<BatchFuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/batch_amend_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling amendBatchFutureOrders.');
        }

        // verify required parameter 'batchAmendOrderReq' is not null or undefined
        if (batchAmendOrderReq === null || batchAmendOrderReq === undefined) {
            throw new Error(
                'Required parameter batchAmendOrderReq was null or undefined when calling amendBatchFutureOrders.',
            );
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(batchAmendOrderReq, 'Array<BatchAmendOrderReq>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<BatchFuturesOrder>>(config, 'Array<BatchFuturesOrder>', authSettings);
    }

    /**
     *
     * @summary List All Price-triggered Orders
     * @param settle Settle currency
     * @param status Only list the orders with this status
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listPriceTriggeredOrders(
        settle: 'btc' | 'usdt',
        status: 'open' | 'finished',
        opts: { contract?: string; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesPriceTriggeredOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listPriceTriggeredOrders.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling listPriceTriggeredOrders.');
        }

        opts = opts || {};
        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'open' | 'finished'");

        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesPriceTriggeredOrder>>(
            config,
            'Array<FuturesPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Create a price-triggered order
     * @param settle Settle currency
     * @param futuresPriceTriggeredOrder
     */
    public async createPriceTriggeredOrder(
        settle: 'btc' | 'usdt',
        futuresPriceTriggeredOrder: FuturesPriceTriggeredOrder,
    ): Promise<{ response: AxiosResponse; body: TriggerOrderResponse }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling createPriceTriggeredOrder.');
        }

        // verify required parameter 'futuresPriceTriggeredOrder' is not null or undefined
        if (futuresPriceTriggeredOrder === null || futuresPriceTriggeredOrder === undefined) {
            throw new Error(
                'Required parameter futuresPriceTriggeredOrder was null or undefined when calling createPriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresPriceTriggeredOrder, 'FuturesPriceTriggeredOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerOrderResponse>(config, 'TriggerOrderResponse', authSettings);
    }

    /**
     *
     * @summary Cancel All Price-triggered Orders
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     */
    public async cancelPriceTriggeredOrderList(
        settle: 'btc' | 'usdt',
        opts: { contract?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesPriceTriggeredOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling cancelPriceTriggeredOrderList.',
            );
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesPriceTriggeredOrder>>(
            config,
            'Array<FuturesPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Get a price-triggered order
     * @param settle Settle currency
     * @param orderId Retrieve the data of the order with the specified ID
     */
    public async getPriceTriggeredOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getPriceTriggeredOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getPriceTriggeredOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesPriceTriggeredOrder>(config, 'FuturesPriceTriggeredOrder', authSettings);
    }

    /**
     *
     * @summary cancel a price-triggered order
     * @param settle Settle currency
     * @param orderId Retrieve the data of the order with the specified ID
     */
    public async cancelPriceTriggeredOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelPriceTriggeredOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelPriceTriggeredOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesPriceTriggeredOrder>(config, 'FuturesPriceTriggeredOrder', authSettings);
    }
}
