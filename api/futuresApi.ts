/**
 * Gate API v4
 * Welcome to Gate.io API  APIv4 provides spot, margin and futures trading operations. There are public APIs to retrieve the real-time market statistics, and private APIs which needs authentication to trade on user\'s behalf.
 *
 * Contact: support@mail.gate.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-locals */
import { Contract } from '../model/contract';
import { ContractStat } from '../model/contractStat';
import { FundingRateRecord } from '../model/fundingRateRecord';
import { FuturesAccount } from '../model/futuresAccount';
import { FuturesAccountBook } from '../model/futuresAccountBook';
import { FuturesCandlestick } from '../model/futuresCandlestick';
import { FuturesLiquidate } from '../model/futuresLiquidate';
import { FuturesOrder } from '../model/futuresOrder';
import { FuturesOrderBook } from '../model/futuresOrderBook';
import { FuturesPriceTriggeredOrder } from '../model/futuresPriceTriggeredOrder';
import { FuturesTicker } from '../model/futuresTicker';
import { FuturesTrade } from '../model/futuresTrade';
import { InsuranceRecord } from '../model/insuranceRecord';
import { MyFuturesTrade } from '../model/myFuturesTrade';
import { Position } from '../model/position';
import { PositionClose } from '../model/positionClose';
import { TriggerOrderResponse } from '../model/triggerOrderResponse';
import { ObjectSerializer } from '../model/models';
import { ApiClient } from './apiClient';
import { AxiosRequestConfig, AxiosResponse } from 'axios';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class FuturesApi {
    protected client: ApiClient;

    constructor(client?: ApiClient) {
        if (client) {
            this.client = client;
        } else {
            this.client = new ApiClient();
        }
    }

    /**
     *
     * @summary List all futures contracts
     * @param settle Settle currency
     */
    public async listFuturesContracts(
        settle: 'btc' | 'usdt',
    ): Promise<{ response: AxiosResponse; body: Array<Contract> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/contracts'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesContracts.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Contract>>(config, 'Array<Contract>', authSettings);
    }

    /**
     *
     * @summary Get a single contract
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async getFuturesContract(
        settle: 'btc' | 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: Contract }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/contracts/{contract}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getFuturesContract.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getFuturesContract.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Contract>(config, 'Contract', authSettings);
    }

    /**
     * Bids will be sorted by price from high to low, while asks sorted reversely
     * @summary Futures order book
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.interval Order depth. 0 means no aggregation is applied. default to 0
     * @param opts.limit Maximum number of order depth data in asks or bids
     * @param opts.withId Whether order book update ID would be returned. This ID increments by 1 on every order book update
     */
    public async listFuturesOrderBook(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { interval?: '0' | '0.1' | '0.01'; limit?: number; withId?: boolean },
    ): Promise<{ response: AxiosResponse; body: FuturesOrderBook }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/order_book'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesOrderBook.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listFuturesOrderBook.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(opts.interval, "'0' | '0.1' | '0.01'");
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.withId !== undefined) {
            localVarQueryParameters['with_id'] = ObjectSerializer.serialize(opts.withId, 'boolean');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<FuturesOrderBook>(config, 'FuturesOrderBook', authSettings);
    }

    /**
     *
     * @summary Futures trading history
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in one list
     * @param opts.lastId Specify list staring point using the id of last record in previous list-query results  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range
     * @param opts.from Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.
     * @param opts.to Specify end time in Unix seconds, default to current time
     */
    public async listFuturesTrades(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { limit?: number; lastId?: string; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesTrade> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/trades'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesTrades.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listFuturesTrades.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.lastId !== undefined) {
            localVarQueryParameters['last_id'] = ObjectSerializer.serialize(opts.lastId, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesTrade>>(config, 'Array<FuturesTrade>', authSettings);
    }

    /**
     * Return specified contract candlesticks. If prefix `contract` with `mark_`, the contract\'s mark price candlesticks are returned; if prefix with `index_`, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying `from`, `to` and `interval`
     * @summary Get futures candlesticks
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified
     * @param opts.to End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time
     * @param opts.limit Maximum recent data points returned. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected.
     * @param opts.interval Interval time between data points
     */
    public async listFuturesCandlesticks(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: {
            from?: number;
            to?: number;
            limit?: number;
            interval?: '10s' | '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d' | '7d';
        },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesCandlestick> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/candlesticks'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesCandlesticks.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listFuturesCandlesticks.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(
                opts.interval,
                "'10s' | '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d' | '7d'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesCandlestick>>(config, 'Array<FuturesCandlestick>', authSettings);
    }

    /**
     *
     * @summary List futures tickers
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     */
    public async listFuturesTickers(
        settle: 'btc' | 'usdt',
        opts: { contract?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesTicker> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/tickers'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesTickers.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesTicker>>(config, 'Array<FuturesTicker>', authSettings);
    }

    /**
     *
     * @summary Funding rate history
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in one list
     */
    public async listFuturesFundingRateHistory(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FundingRateRecord> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/funding_rate'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling listFuturesFundingRateHistory.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling listFuturesFundingRateHistory.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FundingRateRecord>>(config, 'Array<FundingRateRecord>', authSettings);
    }

    /**
     *
     * @summary Futures insurance balance history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in one list
     */
    public async listFuturesInsuranceLedger(
        settle: 'btc' | 'usdt',
        opts: { limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<InsuranceRecord> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/insurance'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesInsuranceLedger.');
        }

        opts = opts || {};
        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<InsuranceRecord>>(config, 'Array<InsuranceRecord>', authSettings);
    }

    /**
     *
     * @summary Futures stats
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.from Start timestamp
     * @param opts.interval
     * @param opts.limit
     */
    public async listContractStats(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { from?: number; interval?: '5m' | '15m' | '30m' | '1h' | '4h' | '1d'; limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<ContractStat> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/contract_stats'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listContractStats.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listContractStats.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(
                opts.interval,
                "'5m' | '15m' | '30m' | '1h' | '4h' | '1d'",
            );
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<ContractStat>>(config, 'Array<ContractStat>', authSettings);
    }

    /**
     * Interval between `from` and `to` cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
     * @summary Retrieve liquidation history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     * @param opts.limit Maximum number of records returned in one list
     */
    public async listLiquidatedOrders(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; from?: number; to?: number; limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesLiquidate> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/liq_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listLiquidatedOrders.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesLiquidate>>(config, 'Array<FuturesLiquidate>', authSettings);
    }

    /**
     *
     * @summary Query futures account
     * @param settle Settle currency
     */
    public async listFuturesAccounts(
        settle: 'btc' | 'usdt',
    ): Promise<{ response: AxiosResponse; body: FuturesAccount }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/accounts'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesAccounts.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesAccount>(config, 'FuturesAccount', authSettings);
    }

    /**
     *
     * @summary Query account book
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in one list
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     * @param opts.type Changing Type: - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate
     */
    public async listFuturesAccountBook(
        settle: 'btc' | 'usdt',
        opts: {
            limit?: number;
            from?: number;
            to?: number;
            type?: 'dnw' | 'pnl' | 'fee' | 'refr' | 'fund' | 'point_dnw' | 'point_fee' | 'point_refr';
        },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesAccountBook> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/account_book'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesAccountBook.');
        }

        opts = opts || {};
        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(
                opts.type,
                "'dnw' | 'pnl' | 'fee' | 'refr' | 'fund' | 'point_dnw' | 'point_fee' | 'point_refr'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesAccountBook>>(config, 'Array<FuturesAccountBook>', authSettings);
    }

    /**
     *
     * @summary List all positions of a user
     * @param settle Settle currency
     */
    public async listPositions(settle: 'btc' | 'usdt'): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listPositions.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     *
     * @summary Get single position
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async getPosition(
        settle: 'btc' | 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getPosition.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getPosition.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *
     * @summary Update position margin
     * @param settle Settle currency
     * @param contract Futures contract
     * @param change Margin change. Use positive number to increase margin, negative number otherwise.
     */
    public async updatePositionMargin(
        settle: 'btc' | 'usdt',
        contract: string,
        change: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}/margin'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling updatePositionMargin.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling updatePositionMargin.');
        }

        // verify required parameter 'change' is not null or undefined
        if (change === null || change === undefined) {
            throw new Error('Required parameter change was null or undefined when calling updatePositionMargin.');
        }

        localVarQueryParameters['change'] = ObjectSerializer.serialize(change, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *
     * @summary Update position leverage
     * @param settle Settle currency
     * @param contract Futures contract
     * @param leverage New position leverage
     */
    public async updatePositionLeverage(
        settle: 'btc' | 'usdt',
        contract: string,
        leverage: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}/leverage'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling updatePositionLeverage.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling updatePositionLeverage.');
        }

        // verify required parameter 'leverage' is not null or undefined
        if (leverage === null || leverage === undefined) {
            throw new Error('Required parameter leverage was null or undefined when calling updatePositionLeverage.');
        }

        localVarQueryParameters['leverage'] = ObjectSerializer.serialize(leverage, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *
     * @summary Update position risk limit
     * @param settle Settle currency
     * @param contract Futures contract
     * @param riskLimit New position risk limit
     */
    public async updatePositionRiskLimit(
        settle: 'btc' | 'usdt',
        contract: string,
        riskLimit: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}/risk_limit'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling updatePositionRiskLimit.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling updatePositionRiskLimit.');
        }

        // verify required parameter 'riskLimit' is not null or undefined
        if (riskLimit === null || riskLimit === undefined) {
            throw new Error('Required parameter riskLimit was null or undefined when calling updatePositionRiskLimit.');
        }

        localVarQueryParameters['risk_limit'] = ObjectSerializer.serialize(riskLimit, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     * Before setting dual mode, make sure all positions are closed and no orders are open
     * @summary Enable or disable dual mode
     * @param settle Settle currency
     * @param dualMode Whether to enable dual mode
     */
    public async setDualMode(
        settle: 'btc' | 'usdt',
        dualMode: boolean,
    ): Promise<{ response: AxiosResponse; body: FuturesAccount }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_mode'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling setDualMode.');
        }

        // verify required parameter 'dualMode' is not null or undefined
        if (dualMode === null || dualMode === undefined) {
            throw new Error('Required parameter dualMode was null or undefined when calling setDualMode.');
        }

        localVarQueryParameters['dual_mode'] = ObjectSerializer.serialize(dualMode, 'boolean');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesAccount>(config, 'FuturesAccount', authSettings);
    }

    /**
     *
     * @summary Retrieve position detail in dual mode
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async getDualModePosition(
        settle: 'btc' | 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/{contract}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getDualModePosition.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getDualModePosition.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     *
     * @summary Update position margin in dual mode
     * @param settle Settle currency
     * @param contract Futures contract
     * @param change Margin change. Use positive number to increase margin, negative number otherwise.
     */
    public async updateDualModePositionMargin(
        settle: 'btc' | 'usdt',
        contract: string,
        change: string,
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/{contract}/margin'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDualModePositionMargin.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateDualModePositionMargin.',
            );
        }

        // verify required parameter 'change' is not null or undefined
        if (change === null || change === undefined) {
            throw new Error(
                'Required parameter change was null or undefined when calling updateDualModePositionMargin.',
            );
        }

        localVarQueryParameters['change'] = ObjectSerializer.serialize(change, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     *
     * @summary Update position leverage in dual mode
     * @param settle Settle currency
     * @param contract Futures contract
     * @param leverage New position leverage
     */
    public async updateDualModePositionLeverage(
        settle: 'btc' | 'usdt',
        contract: string,
        leverage: string,
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/{contract}/leverage'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDualModePositionLeverage.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateDualModePositionLeverage.',
            );
        }

        // verify required parameter 'leverage' is not null or undefined
        if (leverage === null || leverage === undefined) {
            throw new Error(
                'Required parameter leverage was null or undefined when calling updateDualModePositionLeverage.',
            );
        }

        localVarQueryParameters['leverage'] = ObjectSerializer.serialize(leverage, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     *
     * @summary Update position risk limit in dual mode
     * @param settle Settle currency
     * @param contract Futures contract
     * @param riskLimit New position risk limit
     */
    public async updateDualModePositionRiskLimit(
        settle: 'btc' | 'usdt',
        contract: string,
        riskLimit: string,
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/{contract}/risk_limit'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDualModePositionRiskLimit.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateDualModePositionRiskLimit.',
            );
        }

        // verify required parameter 'riskLimit' is not null or undefined
        if (riskLimit === null || riskLimit === undefined) {
            throw new Error(
                'Required parameter riskLimit was null or undefined when calling updateDualModePositionRiskLimit.',
            );
        }

        localVarQueryParameters['risk_limit'] = ObjectSerializer.serialize(riskLimit, 'string');

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     * Zero-fill order cannot be retrieved 60 seconds after cancellation
     * @summary List futures orders
     * @param settle Settle currency
     * @param contract Futures contract
     * @param status List orders based on status
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in one list
     * @param opts.offset List offset, starting from 0
     * @param opts.lastId Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results
     * @param opts.countTotal Whether to return total number matched. Default to 0(no return)
     */
    public async listFuturesOrders(
        settle: 'btc' | 'usdt',
        contract: string,
        status: 'open' | 'finished',
        opts: { limit?: number; offset?: number; lastId?: string; countTotal?: 0 | 1 },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesOrders.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listFuturesOrders.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling listFuturesOrders.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'open' | 'finished'");

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.lastId !== undefined) {
            localVarQueryParameters['last_id'] = ObjectSerializer.serialize(opts.lastId, 'string');
        }

        if (opts.countTotal !== undefined) {
            localVarQueryParameters['count_total'] = ObjectSerializer.serialize(opts.countTotal, '0 | 1');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesOrder>>(config, 'Array<FuturesOrder>', authSettings);
    }

    /**
     * Zero-fill order cannot be retrieved 60 seconds after cancellation
     * @summary Create a futures order
     * @param settle Settle currency
     * @param futuresOrder
     */
    public async createFuturesOrder(
        settle: 'btc' | 'usdt',
        futuresOrder: FuturesOrder,
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling createFuturesOrder.');
        }

        // verify required parameter 'futuresOrder' is not null or undefined
        if (futuresOrder === null || futuresOrder === undefined) {
            throw new Error('Required parameter futuresOrder was null or undefined when calling createFuturesOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresOrder, 'FuturesOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     * Zero-fill order cannot be retrieved 60 seconds after cancellation
     * @summary Cancel all `open` orders matched
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.side All bids or asks. Both included in not specified
     */
    public async cancelFuturesOrders(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { side?: 'ask' | 'bid' },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelFuturesOrders.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling cancelFuturesOrders.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.side !== undefined) {
            localVarQueryParameters['side'] = ObjectSerializer.serialize(opts.side, "'ask' | 'bid'");
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesOrder>>(config, 'Array<FuturesOrder>', authSettings);
    }

    /**
     * Zero-fill order cannot be retrieved 60 seconds after cancellation
     * @summary Get a single order
     * @param settle Settle currency
     * @param orderId ID returned on order successfully being created
     */
    public async getFuturesOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getFuturesOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getFuturesOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     *
     * @summary Cancel a single order
     * @param settle Settle currency
     * @param orderId ID returned on order successfully being created
     */
    public async cancelFuturesOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelFuturesOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelFuturesOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     *
     * @summary List personal trading history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.order Futures order ID, return related data only if specified
     * @param opts.limit Maximum number of records returned in one list
     * @param opts.offset List offset, starting from 0
     * @param opts.lastId Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results
     * @param opts.countTotal Whether to return total number matched. Default to 0(no return)
     */
    public async getMyTrades(
        settle: 'btc' | 'usdt',
        opts: {
            contract?: string;
            order?: number;
            limit?: number;
            offset?: number;
            lastId?: string;
            countTotal?: 0 | 1;
        },
    ): Promise<{ response: AxiosResponse; body: Array<MyFuturesTrade> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/my_trades'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getMyTrades.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(opts.order, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.lastId !== undefined) {
            localVarQueryParameters['last_id'] = ObjectSerializer.serialize(opts.lastId, 'string');
        }

        if (opts.countTotal !== undefined) {
            localVarQueryParameters['count_total'] = ObjectSerializer.serialize(opts.countTotal, '0 | 1');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<MyFuturesTrade>>(config, 'Array<MyFuturesTrade>', authSettings);
    }

    /**
     *
     * @summary List position close history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records returned in one list
     * @param opts.offset List offset, starting from 0
     */
    public async listPositionClose(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<PositionClose> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/position_close'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listPositionClose.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<PositionClose>>(config, 'Array<PositionClose>', authSettings);
    }

    /**
     *
     * @summary List liquidation history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records returned in one list
     * @param opts.at Specify a liquidation timestamp
     */
    public async listLiquidates(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; limit?: number; at?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesLiquidate> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/liquidates'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listLiquidates.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.at !== undefined) {
            localVarQueryParameters['at'] = ObjectSerializer.serialize(opts.at, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesLiquidate>>(config, 'Array<FuturesLiquidate>', authSettings);
    }

    /**
     *
     * @summary List all auto orders
     * @param settle Settle currency
     * @param status List orders based on status
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records returned in one list
     * @param opts.offset List offset, starting from 0
     */
    public async listPriceTriggeredOrders(
        settle: 'btc' | 'usdt',
        status: 'open' | 'finished',
        opts: { contract?: string; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesPriceTriggeredOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listPriceTriggeredOrders.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling listPriceTriggeredOrders.');
        }

        opts = opts || {};
        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'open' | 'finished'");

        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesPriceTriggeredOrder>>(
            config,
            'Array<FuturesPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Create a price-triggered order
     * @param settle Settle currency
     * @param futuresPriceTriggeredOrder
     */
    public async createPriceTriggeredOrder(
        settle: 'btc' | 'usdt',
        futuresPriceTriggeredOrder: FuturesPriceTriggeredOrder,
    ): Promise<{ response: AxiosResponse; body: TriggerOrderResponse }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling createPriceTriggeredOrder.');
        }

        // verify required parameter 'futuresPriceTriggeredOrder' is not null or undefined
        if (futuresPriceTriggeredOrder === null || futuresPriceTriggeredOrder === undefined) {
            throw new Error(
                'Required parameter futuresPriceTriggeredOrder was null or undefined when calling createPriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresPriceTriggeredOrder, 'FuturesPriceTriggeredOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerOrderResponse>(config, 'TriggerOrderResponse', authSettings);
    }

    /**
     *
     * @summary Cancel all open orders
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async cancelPriceTriggeredOrderList(
        settle: 'btc' | 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: Array<FuturesPriceTriggeredOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling cancelPriceTriggeredOrderList.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling cancelPriceTriggeredOrderList.',
            );
        }

        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesPriceTriggeredOrder>>(
            config,
            'Array<FuturesPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Get a single order
     * @param settle Settle currency
     * @param orderId ID returned on order successfully being created
     */
    public async getPriceTriggeredOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getPriceTriggeredOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getPriceTriggeredOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesPriceTriggeredOrder>(config, 'FuturesPriceTriggeredOrder', authSettings);
    }

    /**
     *
     * @summary Cancel a single order
     * @param settle Settle currency
     * @param orderId ID returned on order successfully being created
     */
    public async cancelPriceTriggeredOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelPriceTriggeredOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelPriceTriggeredOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesPriceTriggeredOrder>(config, 'FuturesPriceTriggeredOrder', authSettings);
    }
}
