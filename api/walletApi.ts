/**
 * Gate API
 * Welcome to Gate API APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * Contact: support@mail.gate.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-locals */
import { ConvertSmallBalance } from '../model/convertSmallBalance';
import { CurrencyChain } from '../model/currencyChain';
import { DepositAddress } from '../model/depositAddress';
import { DepositRecord } from '../model/depositRecord';
import { SavedAddress } from '../model/savedAddress';
import { SmallBalance } from '../model/smallBalance';
import { SmallBalanceHistory } from '../model/smallBalanceHistory';
import { SubAccountBalance } from '../model/subAccountBalance';
import { SubAccountCrossMarginBalance } from '../model/subAccountCrossMarginBalance';
import { SubAccountFuturesBalance } from '../model/subAccountFuturesBalance';
import { SubAccountMarginBalance } from '../model/subAccountMarginBalance';
import { SubAccountToSubAccount } from '../model/subAccountToSubAccount';
import { SubAccountTransfer } from '../model/subAccountTransfer';
import { SubAccountTransferRecordItem } from '../model/subAccountTransferRecordItem';
import { TotalBalance } from '../model/totalBalance';
import { TradeFee } from '../model/tradeFee';
import { TransactionID } from '../model/transactionID';
import { Transfer } from '../model/transfer';
import { TransferOrderStatus } from '../model/transferOrderStatus';
import { UidPushOrder } from '../model/uidPushOrder';
import { WithdrawStatus } from '../model/withdrawStatus';
import { WithdrawalRecord } from '../model/withdrawalRecord';
import { ObjectSerializer } from '../model/models';
import { ApiClient } from './apiClient';
import { AxiosRequestConfig, AxiosResponse } from 'axios';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class WalletApi {
    protected client: ApiClient;

    constructor(client?: ApiClient) {
        if (client) {
            this.client = client;
        } else {
            this.client = new ApiClient();
        }
    }

    /**
     *
     * @summary Query chains supported for specified currency
     * @param currency Currency name
     */
    public async listCurrencyChains(
        currency: string,
    ): Promise<{ response: AxiosResponse; body: Array<CurrencyChain> }> {
        const localVarPath = this.client.basePath + '/wallet/currency_chains';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling listCurrencyChains.');
        }

        localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, 'string');

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<CurrencyChain>>(config, 'Array<CurrencyChain>', authSettings);
    }

    /**
     *
     * @summary Generate currency deposit address
     * @param currency Currency name
     */
    public async getDepositAddress(currency: string): Promise<{ response: AxiosResponse; body: DepositAddress }> {
        const localVarPath = this.client.basePath + '/wallet/deposit_address';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling getDepositAddress.');
        }

        localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, 'string');

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<DepositAddress>(config, 'DepositAddress', authSettings);
    }

    /**
     * Record query time range cannot exceed 30 days
     * @summary Get withdrawal records
     * @param opts Optional parameters
     * @param opts.currency Specify the currency. If not specified, returns all currencies
     * @param opts.withdrawId Withdrawal record ID starts with \&#39;w\&#39;, such as: w1879219868. When withdraw_id is not empty, only this specific withdrawal record will be queried, and time-based querying will be disabled
     * @param opts.assetClass Currency type of withdrawal record, empty by default. Supports querying withdrawal records in main zone and innovation zone on demand. Value range: SPOT, PILOT  SPOT: Main Zone PILOT: Innovation Zone
     * @param opts.withdrawOrderId User-defined order number for withdrawal. Default is empty. When not empty, the specified user-defined order number record will be queried
     * @param opts.from Start time for querying records, defaults to 7 days before current time if not specified
     * @param opts.to End timestamp for the query, defaults to current time if not specified
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listWithdrawals(opts: {
        currency?: string;
        withdrawId?: string;
        assetClass?: string;
        withdrawOrderId?: string;
        from?: number;
        to?: number;
        limit?: number;
        offset?: number;
    }): Promise<{ response: AxiosResponse; body: Array<WithdrawalRecord> }> {
        const localVarPath = this.client.basePath + '/wallet/withdrawals';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(opts.currency, 'string');
        }

        if (opts.withdrawId !== undefined) {
            localVarQueryParameters['withdraw_id'] = ObjectSerializer.serialize(opts.withdrawId, 'string');
        }

        if (opts.assetClass !== undefined) {
            localVarQueryParameters['asset_class'] = ObjectSerializer.serialize(opts.assetClass, 'string');
        }

        if (opts.withdrawOrderId !== undefined) {
            localVarQueryParameters['withdraw_order_id'] = ObjectSerializer.serialize(opts.withdrawOrderId, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<WithdrawalRecord>>(config, 'Array<WithdrawalRecord>', authSettings);
    }

    /**
     * Record query time range cannot exceed 30 days
     * @summary Get deposit records
     * @param opts Optional parameters
     * @param opts.currency Specify the currency. If not specified, returns all currencies
     * @param opts.from Start time for querying records, defaults to 7 days before current time if not specified
     * @param opts.to End timestamp for the query, defaults to current time if not specified
     * @param opts.limit Maximum number of entries returned in the list, limited to 500 transactions
     * @param opts.offset List offset, starting from 0
     */
    public async listDeposits(opts: {
        currency?: string;
        from?: number;
        to?: number;
        limit?: number;
        offset?: number;
    }): Promise<{ response: AxiosResponse; body: Array<DepositRecord> }> {
        const localVarPath = this.client.basePath + '/wallet/deposits';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(opts.currency, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<DepositRecord>>(config, 'Array<DepositRecord>', authSettings);
    }

    /**
     * Balance transfers between personal trading accounts. Currently supports the following transfer operations:  1. Spot account - Margin account 2. Spot account - Perpetual futures account 3. Spot account - Delivery futures account 4. Spot account - Options account
     * @summary Transfer between trading accounts
     * @param transfer
     */
    public async transfer(transfer: Transfer): Promise<{ response: AxiosResponse; body: TransactionID }> {
        const localVarPath = this.client.basePath + '/wallet/transfers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'transfer' is not null or undefined
        if (transfer === null || transfer === undefined) {
            throw new Error('Required parameter transfer was null or undefined when calling transfer.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(transfer, 'Transfer'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TransactionID>(config, 'TransactionID', authSettings);
    }

    /**
     * Record query time range cannot exceed 30 days  > Note: Only records after 2020-04-10 can be retrieved
     * @summary Get transfer records between main and sub accounts
     * @param opts Optional parameters
     * @param opts.subUid Sub-account user ID, you can query multiple records separated by &#x60;,&#x60;. If not specified, it will return records of all sub-accounts
     * @param opts.from Start time for querying records, defaults to 7 days before current time if not specified
     * @param opts.to End timestamp for the query, defaults to current time if not specified
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listSubAccountTransfers(opts: {
        subUid?: string;
        from?: number;
        to?: number;
        limit?: number;
        offset?: number;
    }): Promise<{ response: AxiosResponse; body: Array<SubAccountTransferRecordItem> }> {
        const localVarPath = this.client.basePath + '/wallet/sub_account_transfers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.subUid !== undefined) {
            localVarQueryParameters['sub_uid'] = ObjectSerializer.serialize(opts.subUid, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SubAccountTransferRecordItem>>(
            config,
            'Array<SubAccountTransferRecordItem>',
            authSettings,
        );
    }

    /**
     * Supports transfers to/from sub-account\'s spot or futures accounts. Note that regardless of which sub-account is operated, only the main account\'s spot account is used
     * @summary Transfer between main and sub accounts
     * @param subAccountTransfer
     */
    public async transferWithSubAccount(
        subAccountTransfer: SubAccountTransfer,
    ): Promise<{ response: AxiosResponse; body: TransactionID }> {
        const localVarPath = this.client.basePath + '/wallet/sub_account_transfers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'subAccountTransfer' is not null or undefined
        if (subAccountTransfer === null || subAccountTransfer === undefined) {
            throw new Error(
                'Required parameter subAccountTransfer was null or undefined when calling transferWithSubAccount.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(subAccountTransfer, 'SubAccountTransfer'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TransactionID>(config, 'TransactionID', authSettings);
    }

    /**
     * Supports balance transfers between two sub-accounts under the same main account. You can use either the main account\'s API Key or the source sub-account\'s API Key to perform the operation
     * @summary Transfer between sub-accounts
     * @param subAccountToSubAccount
     */
    public async subAccountToSubAccount(
        subAccountToSubAccount: SubAccountToSubAccount,
    ): Promise<{ response: AxiosResponse; body: TransactionID }> {
        const localVarPath = this.client.basePath + '/wallet/sub_account_to_sub_account';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'subAccountToSubAccount' is not null or undefined
        if (subAccountToSubAccount === null || subAccountToSubAccount === undefined) {
            throw new Error(
                'Required parameter subAccountToSubAccount was null or undefined when calling subAccountToSubAccount.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(subAccountToSubAccount, 'SubAccountToSubAccount'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TransactionID>(config, 'TransactionID', authSettings);
    }

    /**
     * Supports querying transfer status based on user-defined client_order_id or tx_id returned by the transfer interface
     * @summary Transfer status query
     * @param opts Optional parameters
     * @param opts.clientOrderId Customer-defined ID to prevent duplicate transfers. Can be a combination of letters (case-sensitive), numbers, hyphens \&#39;-\&#39;, and underscores \&#39;_\&#39;. Can be pure letters or pure numbers with length between 1-64 characters
     * @param opts.txId Transfer operation number, cannot be empty at the same time as client_order_id
     */
    public async getTransferOrderStatus(opts: {
        clientOrderId?: string;
        txId?: string;
    }): Promise<{ response: AxiosResponse; body: TransferOrderStatus }> {
        const localVarPath = this.client.basePath + '/wallet/order_status';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.clientOrderId !== undefined) {
            localVarQueryParameters['client_order_id'] = ObjectSerializer.serialize(opts.clientOrderId, 'string');
        }

        if (opts.txId !== undefined) {
            localVarQueryParameters['tx_id'] = ObjectSerializer.serialize(opts.txId, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<TransferOrderStatus>(config, 'TransferOrderStatus', authSettings);
    }

    /**
     *
     * @summary Query withdrawal status
     * @param opts Optional parameters
     * @param opts.currency Query by specified currency name
     */
    public async listWithdrawStatus(opts: {
        currency?: string;
    }): Promise<{ response: AxiosResponse; body: Array<WithdrawStatus> }> {
        const localVarPath = this.client.basePath + '/wallet/withdraw_status';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(opts.currency, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<WithdrawStatus>>(config, 'Array<WithdrawStatus>', authSettings);
    }

    /**
     *
     * @summary Query sub-account balance information
     * @param opts Optional parameters
     * @param opts.subUid Sub-account user ID, you can query multiple records separated by &#x60;,&#x60;. If not specified, it will return records of all sub-accounts
     */
    public async listSubAccountBalances(opts: {
        subUid?: string;
    }): Promise<{ response: AxiosResponse; body: Array<SubAccountBalance> }> {
        const localVarPath = this.client.basePath + '/wallet/sub_account_balances';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.subUid !== undefined) {
            localVarQueryParameters['sub_uid'] = ObjectSerializer.serialize(opts.subUid, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SubAccountBalance>>(config, 'Array<SubAccountBalance>', authSettings);
    }

    /**
     *
     * @summary Query sub-account isolated margin account balance information
     * @param opts Optional parameters
     * @param opts.subUid Sub-account user ID, you can query multiple records separated by &#x60;,&#x60;. If not specified, it will return records of all sub-accounts
     */
    public async listSubAccountMarginBalances(opts: {
        subUid?: string;
    }): Promise<{ response: AxiosResponse; body: Array<SubAccountMarginBalance> }> {
        const localVarPath = this.client.basePath + '/wallet/sub_account_margin_balances';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.subUid !== undefined) {
            localVarQueryParameters['sub_uid'] = ObjectSerializer.serialize(opts.subUid, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SubAccountMarginBalance>>(
            config,
            'Array<SubAccountMarginBalance>',
            authSettings,
        );
    }

    /**
     *
     * @summary Query sub-account perpetual futures account balance information
     * @param opts Optional parameters
     * @param opts.subUid Sub-account user ID, you can query multiple records separated by &#x60;,&#x60;. If not specified, it will return records of all sub-accounts
     * @param opts.settle Query balance of specified settlement currency
     */
    public async listSubAccountFuturesBalances(opts: {
        subUid?: string;
        settle?: string;
    }): Promise<{ response: AxiosResponse; body: Array<SubAccountFuturesBalance> }> {
        const localVarPath = this.client.basePath + '/wallet/sub_account_futures_balances';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.subUid !== undefined) {
            localVarQueryParameters['sub_uid'] = ObjectSerializer.serialize(opts.subUid, 'string');
        }

        if (opts.settle !== undefined) {
            localVarQueryParameters['settle'] = ObjectSerializer.serialize(opts.settle, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SubAccountFuturesBalance>>(
            config,
            'Array<SubAccountFuturesBalance>',
            authSettings,
        );
    }

    /**
     *
     * @summary Query sub-account cross margin account balance information
     * @param opts Optional parameters
     * @param opts.subUid Sub-account user ID, you can query multiple records separated by &#x60;,&#x60;. If not specified, it will return records of all sub-accounts
     */
    public async listSubAccountCrossMarginBalances(opts: {
        subUid?: string;
    }): Promise<{ response: AxiosResponse; body: Array<SubAccountCrossMarginBalance> }> {
        const localVarPath = this.client.basePath + '/wallet/sub_account_cross_margin_balances';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.subUid !== undefined) {
            localVarQueryParameters['sub_uid'] = ObjectSerializer.serialize(opts.subUid, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SubAccountCrossMarginBalance>>(
            config,
            'Array<SubAccountCrossMarginBalance>',
            authSettings,
        );
    }

    /**
     *
     * @summary Query withdrawal address whitelist
     * @param currency Currency
     * @param opts Optional parameters
     * @param opts.chain Chain name
     * @param opts.limit Maximum number returned, up to 100
     * @param opts.page Page number
     */
    public async listSavedAddress(
        currency: string,
        opts: { chain?: string; limit?: string; page?: number },
    ): Promise<{ response: AxiosResponse; body: Array<SavedAddress> }> {
        const localVarPath = this.client.basePath + '/wallet/saved_address';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling listSavedAddress.');
        }

        opts = opts || {};
        localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, 'string');

        if (opts.chain !== undefined) {
            localVarQueryParameters['chain'] = ObjectSerializer.serialize(opts.chain, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'string');
        }

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SavedAddress>>(config, 'Array<SavedAddress>', authSettings);
    }

    /**
     *
     * @summary Query personal trading fees
     * @param opts Optional parameters
     * @param opts.currencyPair Specify currency pair to get more accurate fee settings.  This field is optional. Usually fee settings are the same for all currency pairs.
     * @param opts.settle Specify the settlement currency of the contract to get more accurate fee settings.  This field is optional. Generally, the fee settings for all settlement currencies are the same.
     */
    public async getTradeFee(opts: {
        currencyPair?: string;
        settle?: 'BTC' | 'USDT' | 'USD';
    }): Promise<{ response: AxiosResponse; body: TradeFee }> {
        const localVarPath = this.client.basePath + '/wallet/fee';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currencyPair !== undefined) {
            localVarQueryParameters['currency_pair'] = ObjectSerializer.serialize(opts.currencyPair, 'string');
        }

        if (opts.settle !== undefined) {
            localVarQueryParameters['settle'] = ObjectSerializer.serialize(opts.settle, "'BTC' | 'USDT' | 'USD'");
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<TradeFee>(config, 'TradeFee', authSettings);
    }

    /**
     * This query endpoint returns the total *estimated value* of all currencies in each account converted to the input currency. Exchange rates and related account balance information may be cached for up to 1 minute. It is not recommended to use this interface data for real-time calculations.  For real-time calculations, query the corresponding balance interface based on account type, such as:  - `GET /spot/accounts` to query spot account - `GET /margin/accounts` to query margin account - `GET /futures/{settle}/accounts` to query futures account
     * @summary Query personal account totals
     * @param opts Optional parameters
     * @param opts.currency Target currency type for statistical conversion. Accepts BTC, CNY, USD, and USDT. USDT is the default value
     */
    public async getTotalBalance(opts: {
        currency?: string;
    }): Promise<{ response: AxiosResponse; body: TotalBalance }> {
        const localVarPath = this.client.basePath + '/wallet/total_balance';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(opts.currency, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<TotalBalance>(config, 'TotalBalance', authSettings);
    }

    /**
     *
     * @summary Get list of convertible small balance currencies
     */
    public async listSmallBalance(): Promise<{ response: AxiosResponse; body: Array<SmallBalance> }> {
        const localVarPath = this.client.basePath + '/wallet/small_balance';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SmallBalance>>(config, 'Array<SmallBalance>', authSettings);
    }

    /**
     *
     * @summary Convert small balance currency
     * @param convertSmallBalance
     */
    public async convertSmallBalance(
        convertSmallBalance: ConvertSmallBalance,
    ): Promise<{ response: AxiosResponse; body?: any }> {
        const localVarPath = this.client.basePath + '/wallet/small_balance';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);

        // verify required parameter 'convertSmallBalance' is not null or undefined
        if (convertSmallBalance === null || convertSmallBalance === undefined) {
            throw new Error(
                'Required parameter convertSmallBalance was null or undefined when calling convertSmallBalance.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(convertSmallBalance, 'ConvertSmallBalance'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<any>(config, '', authSettings);
    }

    /**
     *
     * @summary Get convertible small balance currency history
     * @param opts Optional parameters
     * @param opts.currency Currency to convert
     * @param opts.page Page number
     * @param opts.limit Maximum number of items returned. Default: 100, minimum: 1, maximum: 100
     */
    public async listSmallBalanceHistory(opts: {
        currency?: string;
        page?: number;
        limit?: number;
    }): Promise<{ response: AxiosResponse; body: Array<SmallBalanceHistory> }> {
        const localVarPath = this.client.basePath + '/wallet/small_balance_history';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(opts.currency, 'string');
        }

        if (opts.page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(opts.page, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<SmallBalanceHistory>>(config, 'Array<SmallBalanceHistory>', authSettings);
    }

    /**
     *
     * @summary Get UID transfer history
     * @param opts Optional parameters
     * @param opts.id Order ID
     * @param opts.from Start time for querying records. If not specified, defaults to 7 days before the current time. Unix timestamp in seconds
     * @param opts.to End time for querying records. If not specified, defaults to the current time. Unix timestamp in seconds
     * @param opts.limit Maximum number of items returned in the list, default value is 100
     * @param opts.offset List offset, starting from 0
     * @param opts.transactionType Order type returned in the list: &#x60;withdraw&#x60;, &#x60;deposit&#x60;. Default is &#x60;withdraw&#x60;.
     */
    public async listPushOrders(opts: {
        id?: number;
        from?: number;
        to?: number;
        limit?: number;
        offset?: number;
        transactionType?: string;
    }): Promise<{ response: AxiosResponse; body: Array<UidPushOrder> }> {
        const localVarPath = this.client.basePath + '/wallet/push';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(opts.id, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.transactionType !== undefined) {
            localVarQueryParameters['transaction_type'] = ObjectSerializer.serialize(opts.transactionType, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<UidPushOrder>>(config, 'Array<UidPushOrder>', authSettings);
    }
}
