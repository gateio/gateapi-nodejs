/**
 * Gate API
 * Welcome to Gate API APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * Contact: support@mail.gate.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-locals */
import { CountdownCancelAllOptionsTask } from '../model/countdownCancelAllOptionsTask';
import { FuturesCandlestick } from '../model/futuresCandlestick';
import { FuturesOrderBook } from '../model/futuresOrderBook';
import { FuturesTrade } from '../model/futuresTrade';
import { OptionsAccount } from '../model/optionsAccount';
import { OptionsAccountBook } from '../model/optionsAccountBook';
import { OptionsCandlestick } from '../model/optionsCandlestick';
import { OptionsContract } from '../model/optionsContract';
import { OptionsMMP } from '../model/optionsMMP';
import { OptionsMMPReset } from '../model/optionsMMPReset';
import { OptionsMySettlements } from '../model/optionsMySettlements';
import { OptionsMyTrade } from '../model/optionsMyTrade';
import { OptionsOrder } from '../model/optionsOrder';
import { OptionsPosition } from '../model/optionsPosition';
import { OptionsPositionClose } from '../model/optionsPositionClose';
import { OptionsSettlement } from '../model/optionsSettlement';
import { OptionsTicker } from '../model/optionsTicker';
import { OptionsUnderlying } from '../model/optionsUnderlying';
import { OptionsUnderlyingTicker } from '../model/optionsUnderlyingTicker';
import { TriggerTime } from '../model/triggerTime';
import { ObjectSerializer } from '../model/models';
import { ApiClient } from './apiClient';
import { AxiosRequestConfig, AxiosResponse } from 'axios';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class OptionsApi {
    protected client: ApiClient;

    constructor(client?: ApiClient) {
        if (client) {
            this.client = client;
        } else {
            this.client = new ApiClient();
        }
    }

    /**
     *
     * @summary List all underlying assets
     */
    public async listOptionsUnderlyings(): Promise<{ response: AxiosResponse; body: Array<OptionsUnderlying> }> {
        const localVarPath = this.client.basePath + '/options/underlyings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<OptionsUnderlying>>(config, 'Array<OptionsUnderlying>', authSettings);
    }

    /**
     *
     * @summary List all expiration dates
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     */
    public async listOptionsExpirations(underlying: string): Promise<{ response: AxiosResponse; body: Array<number> }> {
        const localVarPath = this.client.basePath + '/options/expirations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error('Required parameter underlying was null or undefined when calling listOptionsExpirations.');
        }

        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<number>>(config, 'Array<number>', authSettings);
    }

    /**
     *
     * @summary List all contracts for specified underlying and expiration date
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param opts Optional parameters
     * @param opts.expiration Unix timestamp of expiration date
     */
    public async listOptionsContracts(
        underlying: string,
        opts: { expiration?: number },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsContract> }> {
        const localVarPath = this.client.basePath + '/options/contracts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error('Required parameter underlying was null or undefined when calling listOptionsContracts.');
        }

        opts = opts || {};
        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        if (opts.expiration !== undefined) {
            localVarQueryParameters['expiration'] = ObjectSerializer.serialize(opts.expiration, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<OptionsContract>>(config, 'Array<OptionsContract>', authSettings);
    }

    /**
     *
     * @summary Query specified contract details
     * @param contract
     */
    public async getOptionsContract(contract: string): Promise<{ response: AxiosResponse; body: OptionsContract }> {
        const localVarPath =
            this.client.basePath +
            '/options/contracts/{contract}'.replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getOptionsContract.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<OptionsContract>(config, 'OptionsContract', authSettings);
    }

    /**
     *
     * @summary List settlement history
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     */
    public async listOptionsSettlements(
        underlying: string,
        opts: { limit?: number; offset?: number; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsSettlement> }> {
        const localVarPath = this.client.basePath + '/options/settlements';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error('Required parameter underlying was null or undefined when calling listOptionsSettlements.');
        }

        opts = opts || {};
        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<OptionsSettlement>>(config, 'Array<OptionsSettlement>', authSettings);
    }

    /**
     *
     * @summary Get specified contract settlement information
     * @param contract
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param at
     */
    public async getOptionsSettlement(
        contract: string,
        underlying: string,
        at: number,
    ): Promise<{ response: AxiosResponse; body: OptionsSettlement }> {
        const localVarPath =
            this.client.basePath +
            '/options/settlements/{contract}'.replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getOptionsSettlement.');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error('Required parameter underlying was null or undefined when calling getOptionsSettlement.');
        }

        // verify required parameter 'at' is not null or undefined
        if (at === null || at === undefined) {
            throw new Error('Required parameter at was null or undefined when calling getOptionsSettlement.');
        }

        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        localVarQueryParameters['at'] = ObjectSerializer.serialize(at, 'number');

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<OptionsSettlement>(config, 'OptionsSettlement', authSettings);
    }

    /**
     *
     * @summary Query personal settlement records
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param opts Optional parameters
     * @param opts.contract Options contract name
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     */
    public async listMyOptionsSettlements(
        underlying: string,
        opts: { contract?: string; limit?: number; offset?: number; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsMySettlements> }> {
        const localVarPath = this.client.basePath + '/options/my_settlements';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error(
                'Required parameter underlying was null or undefined when calling listMyOptionsSettlements.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsMySettlements>>(config, 'Array<OptionsMySettlements>', authSettings);
    }

    /**
     * Bids will be sorted by price from high to low, while asks sorted reversely
     * @summary Query options contract order book
     * @param contract Options contract name
     * @param opts Optional parameters
     * @param opts.interval Price precision for depth aggregation, 0 means no aggregation, defaults to 0 if not specified
     * @param opts.limit Number of depth levels
     * @param opts.withId Whether to return depth update ID. This ID increments by 1 each time depth changes
     */
    public async listOptionsOrderBook(
        contract: string,
        opts: { interval?: '0' | '0.1' | '0.01'; limit?: number; withId?: boolean },
    ): Promise<{ response: AxiosResponse; body: FuturesOrderBook }> {
        const localVarPath = this.client.basePath + '/options/order_book';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listOptionsOrderBook.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(opts.interval, "'0' | '0.1' | '0.01'");
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.withId !== undefined) {
            localVarQueryParameters['with_id'] = ObjectSerializer.serialize(opts.withId, 'boolean');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<FuturesOrderBook>(config, 'FuturesOrderBook', authSettings);
    }

    /**
     *
     * @summary Query options market ticker information
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     */
    public async listOptionsTickers(
        underlying: string,
    ): Promise<{ response: AxiosResponse; body: Array<OptionsTicker> }> {
        const localVarPath = this.client.basePath + '/options/tickers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error('Required parameter underlying was null or undefined when calling listOptionsTickers.');
        }

        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<OptionsTicker>>(config, 'Array<OptionsTicker>', authSettings);
    }

    /**
     *
     * @summary Query underlying ticker information
     * @param underlying Underlying
     */
    public async listOptionsUnderlyingTickers(
        underlying: string,
    ): Promise<{ response: AxiosResponse; body: OptionsUnderlyingTicker }> {
        const localVarPath =
            this.client.basePath +
            '/options/underlying/tickers/{underlying}'.replace(
                '{' + 'underlying' + '}',
                encodeURIComponent(String(underlying)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error(
                'Required parameter underlying was null or undefined when calling listOptionsUnderlyingTickers.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<OptionsUnderlyingTicker>(config, 'OptionsUnderlyingTicker', authSettings);
    }

    /**
     *
     * @summary Options contract market candlestick chart
     * @param contract Options contract name
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     * @param opts.interval Time interval between data points
     */
    public async listOptionsCandlesticks(
        contract: string,
        opts: { limit?: number; from?: number; to?: number; interval?: '1m' | '5m' | '15m' | '30m' | '1h' },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsCandlestick> }> {
        const localVarPath = this.client.basePath + '/options/candlesticks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listOptionsCandlesticks.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(
                opts.interval,
                "'1m' | '5m' | '15m' | '30m' | '1h'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<OptionsCandlestick>>(config, 'Array<OptionsCandlestick>', authSettings);
    }

    /**
     *
     * @summary Underlying index price candlestick chart
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     * @param opts.interval Time interval between data points
     */
    public async listOptionsUnderlyingCandlesticks(
        underlying: string,
        opts: { limit?: number; from?: number; to?: number; interval?: '1m' | '5m' | '15m' | '30m' | '1h' },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesCandlestick> }> {
        const localVarPath = this.client.basePath + '/options/underlying/candlesticks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error(
                'Required parameter underlying was null or undefined when calling listOptionsUnderlyingCandlesticks.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(
                opts.interval,
                "'1m' | '5m' | '15m' | '30m' | '1h'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesCandlestick>>(config, 'Array<FuturesCandlestick>', authSettings);
    }

    /**
     *
     * @summary Market trade records
     * @param opts Optional parameters
     * @param opts.contract Options contract name
     * @param opts.type &#x60;C&#x60; for call, &#x60;P&#x60; for put
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     */
    public async listOptionsTrades(opts: {
        contract?: string;
        type?: string;
        limit?: number;
        offset?: number;
        from?: number;
        to?: number;
    }): Promise<{ response: AxiosResponse; body: Array<FuturesTrade> }> {
        const localVarPath = this.client.basePath + '/options/trades';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(opts.type, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesTrade>>(config, 'Array<FuturesTrade>', authSettings);
    }

    /**
     *
     * @summary Query account information
     */
    public async listOptionsAccount(): Promise<{ response: AxiosResponse; body: OptionsAccount }> {
        const localVarPath = this.client.basePath + '/options/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsAccount>(config, 'OptionsAccount', authSettings);
    }

    /**
     *
     * @summary Query account change history
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     * @param opts.type Change types: - dnw: Deposit &amp; Withdrawal - prem: Trading premium - fee: Trading fee - refr: Referrer rebate - set: Settlement P&amp;L
     */
    public async listOptionsAccountBook(opts: {
        limit?: number;
        offset?: number;
        from?: number;
        to?: number;
        type?: 'dnw' | 'prem' | 'fee' | 'refr' | 'set';
    }): Promise<{ response: AxiosResponse; body: Array<OptionsAccountBook> }> {
        const localVarPath = this.client.basePath + '/options/account_book';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(
                opts.type,
                "'dnw' | 'prem' | 'fee' | 'refr' | 'set'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsAccountBook>>(config, 'Array<OptionsAccountBook>', authSettings);
    }

    /**
     *
     * @summary List user\'s positions of specified underlying
     * @param opts Optional parameters
     * @param opts.underlying Underlying
     */
    public async listOptionsPositions(opts: {
        underlying?: string;
    }): Promise<{ response: AxiosResponse; body: Array<OptionsPosition> }> {
        const localVarPath = this.client.basePath + '/options/positions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.underlying !== undefined) {
            localVarQueryParameters['underlying'] = ObjectSerializer.serialize(opts.underlying, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsPosition>>(config, 'Array<OptionsPosition>', authSettings);
    }

    /**
     *
     * @summary Get specified contract position
     * @param contract
     */
    public async getOptionsPosition(contract: string): Promise<{ response: AxiosResponse; body: OptionsPosition }> {
        const localVarPath =
            this.client.basePath +
            '/options/positions/{contract}'.replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getOptionsPosition.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsPosition>(config, 'OptionsPosition', authSettings);
    }

    /**
     *
     * @summary List user\'s liquidation history of specified underlying
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param opts Optional parameters
     * @param opts.contract Options contract name
     */
    public async listOptionsPositionClose(
        underlying: string,
        opts: { contract?: string },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsPositionClose> }> {
        const localVarPath = this.client.basePath + '/options/position_close';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error(
                'Required parameter underlying was null or undefined when calling listOptionsPositionClose.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsPositionClose>>(config, 'Array<OptionsPositionClose>', authSettings);
    }

    /**
     *
     * @summary List options orders
     * @param status Query order list based on status
     * @param opts Optional parameters
     * @param opts.contract Options contract name
     * @param opts.underlying Underlying
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     */
    public async listOptionsOrders(
        status: 'open' | 'finished',
        opts: { contract?: string; underlying?: string; limit?: number; offset?: number; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsOrder> }> {
        const localVarPath = this.client.basePath + '/options/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling listOptionsOrders.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.underlying !== undefined) {
            localVarQueryParameters['underlying'] = ObjectSerializer.serialize(opts.underlying, 'string');
        }

        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'open' | 'finished'");

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsOrder>>(config, 'Array<OptionsOrder>', authSettings);
    }

    /**
     *
     * @summary Create an options order
     * @param optionsOrder
     */
    public async createOptionsOrder(
        optionsOrder: OptionsOrder,
    ): Promise<{ response: AxiosResponse; body: OptionsOrder }> {
        const localVarPath = this.client.basePath + '/options/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'optionsOrder' is not null or undefined
        if (optionsOrder === null || optionsOrder === undefined) {
            throw new Error('Required parameter optionsOrder was null or undefined when calling createOptionsOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(optionsOrder, 'OptionsOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsOrder>(config, 'OptionsOrder', authSettings);
    }

    /**
     *
     * @summary Cancel all orders with \'open\' status
     * @param opts Optional parameters
     * @param opts.contract Options contract name
     * @param opts.underlying Underlying
     * @param opts.side Specify all bids or all asks, both included if not specified
     */
    public async cancelOptionsOrders(opts: {
        contract?: string;
        underlying?: string;
        side?: 'ask' | 'bid';
    }): Promise<{ response: AxiosResponse; body: Array<OptionsOrder> }> {
        const localVarPath = this.client.basePath + '/options/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.underlying !== undefined) {
            localVarQueryParameters['underlying'] = ObjectSerializer.serialize(opts.underlying, 'string');
        }

        if (opts.side !== undefined) {
            localVarQueryParameters['side'] = ObjectSerializer.serialize(opts.side, "'ask' | 'bid'");
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsOrder>>(config, 'Array<OptionsOrder>', authSettings);
    }

    /**
     *
     * @summary Query single order details
     * @param orderId Order ID returned when order is successfully created
     */
    public async getOptionsOrder(orderId: number): Promise<{ response: AxiosResponse; body: OptionsOrder }> {
        const localVarPath =
            this.client.basePath +
            '/options/orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOptionsOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsOrder>(config, 'OptionsOrder', authSettings);
    }

    /**
     *
     * @summary Cancel single order
     * @param orderId Order ID returned when order is successfully created
     */
    public async cancelOptionsOrder(orderId: number): Promise<{ response: AxiosResponse; body: OptionsOrder }> {
        const localVarPath =
            this.client.basePath +
            '/options/orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelOptionsOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsOrder>(config, 'OptionsOrder', authSettings);
    }

    /**
     * Option order heartbeat detection, when the `timeout` time set by the user is reached, if the existing countdown is not canceled or a new countdown is set, the related `option pending order` will be automatically canceled.  This interface can be called repeatedly to set a new countdown or cancel the countdown.  Usage example: Repeat this interface at intervals of 30 seconds, with each countdown `timeout` set to 30 (seconds).  If this interface is not called again within 30 seconds, all pending orders on the `underlying` `contract` you specified will be automatically cancelled. If `underlying` `contract` is not specified, user will be automatically cancelled  If `timeout` is set to 0 within 30 seconds, the countdown timer will expire and the automatic order cancellation function will be cancelled.
     * @summary Countdown cancel orders
     * @param countdownCancelAllOptionsTask
     */
    public async countdownCancelAllOptions(
        countdownCancelAllOptionsTask: CountdownCancelAllOptionsTask,
    ): Promise<{ response: AxiosResponse; body: TriggerTime }> {
        const localVarPath = this.client.basePath + '/options/countdown_cancel_all';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'countdownCancelAllOptionsTask' is not null or undefined
        if (countdownCancelAllOptionsTask === null || countdownCancelAllOptionsTask === undefined) {
            throw new Error(
                'Required parameter countdownCancelAllOptionsTask was null or undefined when calling countdownCancelAllOptions.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(countdownCancelAllOptionsTask, 'CountdownCancelAllOptionsTask'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerTime>(config, 'TriggerTime', authSettings);
    }

    /**
     *
     * @summary Query personal trading records
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param opts Optional parameters
     * @param opts.contract Options contract name
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     */
    public async listMyOptionsTrades(
        underlying: string,
        opts: { contract?: string; limit?: number; offset?: number; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsMyTrade> }> {
        const localVarPath = this.client.basePath + '/options/my_trades';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error('Required parameter underlying was null or undefined when calling listMyOptionsTrades.');
        }

        opts = opts || {};
        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsMyTrade>>(config, 'Array<OptionsMyTrade>', authSettings);
    }

    /**
     *
     * @summary MMP Query.
     * @param opts Optional parameters
     * @param opts.underlying Underlying
     */
    public async getOptionsMMP(opts: {
        underlying?: string;
    }): Promise<{ response: AxiosResponse; body: Array<OptionsMMP> }> {
        const localVarPath = this.client.basePath + '/options/mmp';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.underlying !== undefined) {
            localVarQueryParameters['underlying'] = ObjectSerializer.serialize(opts.underlying, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsMMP>>(config, 'Array<OptionsMMP>', authSettings);
    }

    /**
     *
     * @summary MMP Settings
     * @param optionsMMP
     */
    public async setOptionsMMP(optionsMMP: OptionsMMP): Promise<{ response: AxiosResponse; body: OptionsMMP }> {
        const localVarPath = this.client.basePath + '/options/mmp';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'optionsMMP' is not null or undefined
        if (optionsMMP === null || optionsMMP === undefined) {
            throw new Error('Required parameter optionsMMP was null or undefined when calling setOptionsMMP.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(optionsMMP, 'OptionsMMP'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsMMP>(config, 'OptionsMMP', authSettings);
    }

    /**
     *
     * @summary MMP Reset
     * @param optionsMMPReset
     */
    public async resetOptionsMMP(
        optionsMMPReset: OptionsMMPReset,
    ): Promise<{ response: AxiosResponse; body: OptionsMMP }> {
        const localVarPath = this.client.basePath + '/options/mmp/reset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'optionsMMPReset' is not null or undefined
        if (optionsMMPReset === null || optionsMMPReset === undefined) {
            throw new Error('Required parameter optionsMMPReset was null or undefined when calling resetOptionsMMP.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(optionsMMPReset, 'OptionsMMPReset'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsMMP>(config, 'OptionsMMP', authSettings);
    }
}
