/**
 * Gate API v4
 * Welcome to Gate.io API  APIv4 provides spot, margin and futures trading operations. There are public APIs to retrieve the real-time market statistics, and private APIs which needs authentication to trade on user\'s behalf.
 *
 * Contact: support@mail.gate.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-locals */
import { CountdownCancelAllOptionsTask } from '../model/countdownCancelAllOptionsTask';
import { FuturesCandlestick } from '../model/futuresCandlestick';
import { FuturesOrderBook } from '../model/futuresOrderBook';
import { FuturesTrade } from '../model/futuresTrade';
import { OptionsAccount } from '../model/optionsAccount';
import { OptionsAccountBook } from '../model/optionsAccountBook';
import { OptionsCandlestick } from '../model/optionsCandlestick';
import { OptionsContract } from '../model/optionsContract';
import { OptionsMMP } from '../model/optionsMMP';
import { OptionsMMPReset } from '../model/optionsMMPReset';
import { OptionsMySettlements } from '../model/optionsMySettlements';
import { OptionsMyTrade } from '../model/optionsMyTrade';
import { OptionsOrder } from '../model/optionsOrder';
import { OptionsPosition } from '../model/optionsPosition';
import { OptionsPositionClose } from '../model/optionsPositionClose';
import { OptionsSettlement } from '../model/optionsSettlement';
import { OptionsTicker } from '../model/optionsTicker';
import { OptionsUnderlying } from '../model/optionsUnderlying';
import { OptionsUnderlyingTicker } from '../model/optionsUnderlyingTicker';
import { TriggerTime } from '../model/triggerTime';
import { ObjectSerializer } from '../model/models';
import { ApiClient } from './apiClient';
import { AxiosRequestConfig, AxiosResponse } from 'axios';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class OptionsApi {
    protected client: ApiClient;

    constructor(client?: ApiClient) {
        if (client) {
            this.client = client;
        } else {
            this.client = new ApiClient();
        }
    }

    /**
     *
     * @summary List all underlyings
     */
    public async listOptionsUnderlyings(): Promise<{ response: AxiosResponse; body: Array<OptionsUnderlying> }> {
        const localVarPath = this.client.basePath + '/options/underlyings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<OptionsUnderlying>>(config, 'Array<OptionsUnderlying>', authSettings);
    }

    /**
     *
     * @summary List all expiration times
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     */
    public async listOptionsExpirations(underlying: string): Promise<{ response: AxiosResponse; body: Array<number> }> {
        const localVarPath = this.client.basePath + '/options/expirations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error('Required parameter underlying was null or undefined when calling listOptionsExpirations.');
        }

        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<number>>(config, 'Array<number>', authSettings);
    }

    /**
     *
     * @summary List all the contracts with specified underlying and expiration time
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param opts Optional parameters
     * @param opts.expiration Unix timestamp of the expiration time
     */
    public async listOptionsContracts(
        underlying: string,
        opts: { expiration?: number },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsContract> }> {
        const localVarPath = this.client.basePath + '/options/contracts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error('Required parameter underlying was null or undefined when calling listOptionsContracts.');
        }

        opts = opts || {};
        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        if (opts.expiration !== undefined) {
            localVarQueryParameters['expiration'] = ObjectSerializer.serialize(opts.expiration, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<OptionsContract>>(config, 'Array<OptionsContract>', authSettings);
    }

    /**
     *
     * @summary Query specified contract detail
     * @param contract
     */
    public async getOptionsContract(contract: string): Promise<{ response: AxiosResponse; body: OptionsContract }> {
        const localVarPath =
            this.client.basePath +
            '/options/contracts/{contract}'.replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getOptionsContract.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<OptionsContract>(config, 'OptionsContract', authSettings);
    }

    /**
     *
     * @summary List settlement history
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     */
    public async listOptionsSettlements(
        underlying: string,
        opts: { limit?: number; offset?: number; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsSettlement> }> {
        const localVarPath = this.client.basePath + '/options/settlements';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error('Required parameter underlying was null or undefined when calling listOptionsSettlements.');
        }

        opts = opts || {};
        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<OptionsSettlement>>(config, 'Array<OptionsSettlement>', authSettings);
    }

    /**
     *
     * @summary Get specified contract\'s settlement
     * @param contract
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param at
     */
    public async getOptionsSettlement(
        contract: string,
        underlying: string,
        at: number,
    ): Promise<{ response: AxiosResponse; body: OptionsSettlement }> {
        const localVarPath =
            this.client.basePath +
            '/options/settlements/{contract}'.replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getOptionsSettlement.');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error('Required parameter underlying was null or undefined when calling getOptionsSettlement.');
        }

        // verify required parameter 'at' is not null or undefined
        if (at === null || at === undefined) {
            throw new Error('Required parameter at was null or undefined when calling getOptionsSettlement.');
        }

        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        localVarQueryParameters['at'] = ObjectSerializer.serialize(at, 'number');

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<OptionsSettlement>(config, 'OptionsSettlement', authSettings);
    }

    /**
     *
     * @summary List my options settlements
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param opts Optional parameters
     * @param opts.contract Options contract name
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     */
    public async listMyOptionsSettlements(
        underlying: string,
        opts: { contract?: string; limit?: number; offset?: number; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsMySettlements> }> {
        const localVarPath = this.client.basePath + '/options/my_settlements';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error(
                'Required parameter underlying was null or undefined when calling listMyOptionsSettlements.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsMySettlements>>(config, 'Array<OptionsMySettlements>', authSettings);
    }

    /**
     * Bids will be sorted by price from high to low, while asks sorted reversely
     * @summary Options order book
     * @param contract Options contract name
     * @param opts Optional parameters
     * @param opts.interval Order depth. 0 means no aggregation is applied. default to 0
     * @param opts.limit Maximum number of order depth data in asks or bids
     * @param opts.withId Whether the order book update ID will be returned. This ID increases by 1 on every order book update
     */
    public async listOptionsOrderBook(
        contract: string,
        opts: { interval?: '0' | '0.1' | '0.01'; limit?: number; withId?: boolean },
    ): Promise<{ response: AxiosResponse; body: FuturesOrderBook }> {
        const localVarPath = this.client.basePath + '/options/order_book';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listOptionsOrderBook.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(opts.interval, "'0' | '0.1' | '0.01'");
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.withId !== undefined) {
            localVarQueryParameters['with_id'] = ObjectSerializer.serialize(opts.withId, 'boolean');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<FuturesOrderBook>(config, 'FuturesOrderBook', authSettings);
    }

    /**
     *
     * @summary List tickers of options contracts
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     */
    public async listOptionsTickers(
        underlying: string,
    ): Promise<{ response: AxiosResponse; body: Array<OptionsTicker> }> {
        const localVarPath = this.client.basePath + '/options/tickers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error('Required parameter underlying was null or undefined when calling listOptionsTickers.');
        }

        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<OptionsTicker>>(config, 'Array<OptionsTicker>', authSettings);
    }

    /**
     *
     * @summary Get underlying ticker
     * @param underlying Underlying
     */
    public async listOptionsUnderlyingTickers(
        underlying: string,
    ): Promise<{ response: AxiosResponse; body: OptionsUnderlyingTicker }> {
        const localVarPath =
            this.client.basePath +
            '/options/underlying/tickers/{underlying}'.replace(
                '{' + 'underlying' + '}',
                encodeURIComponent(String(underlying)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error(
                'Required parameter underlying was null or undefined when calling listOptionsUnderlyingTickers.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<OptionsUnderlyingTicker>(config, 'OptionsUnderlyingTicker', authSettings);
    }

    /**
     *
     * @summary Get options candlesticks
     * @param contract Options contract name
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     * @param opts.interval Interval time between data points
     */
    public async listOptionsCandlesticks(
        contract: string,
        opts: { limit?: number; from?: number; to?: number; interval?: '1m' | '5m' | '15m' | '30m' | '1h' },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsCandlestick> }> {
        const localVarPath = this.client.basePath + '/options/candlesticks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listOptionsCandlesticks.');
        }

        opts = opts || {};
        localVarQueryParameters['contract'] = ObjectSerializer.serialize(contract, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(
                opts.interval,
                "'1m' | '5m' | '15m' | '30m' | '1h'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<OptionsCandlestick>>(config, 'Array<OptionsCandlestick>', authSettings);
    }

    /**
     *
     * @summary Mark price candlesticks of an underlying
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     * @param opts.interval Interval time between data points
     */
    public async listOptionsUnderlyingCandlesticks(
        underlying: string,
        opts: { limit?: number; from?: number; to?: number; interval?: '1m' | '5m' | '15m' | '30m' | '1h' },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesCandlestick> }> {
        const localVarPath = this.client.basePath + '/options/underlying/candlesticks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error(
                'Required parameter underlying was null or undefined when calling listOptionsUnderlyingCandlesticks.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(
                opts.interval,
                "'1m' | '5m' | '15m' | '30m' | '1h'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesCandlestick>>(config, 'Array<FuturesCandlestick>', authSettings);
    }

    /**
     *
     * @summary Options trade history
     * @param opts Optional parameters
     * @param opts.contract Options contract name
     * @param opts.type &#x60;C&#x60; is call, while &#x60;P&#x60; is put
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     */
    public async listOptionsTrades(opts: {
        contract?: string;
        type?: string;
        limit?: number;
        offset?: number;
        from?: number;
        to?: number;
    }): Promise<{ response: AxiosResponse; body: Array<FuturesTrade> }> {
        const localVarPath = this.client.basePath + '/options/trades';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(opts.type, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesTrade>>(config, 'Array<FuturesTrade>', authSettings);
    }

    /**
     *
     * @summary List options account
     */
    public async listOptionsAccount(): Promise<{ response: AxiosResponse; body: OptionsAccount }> {
        const localVarPath = this.client.basePath + '/options/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsAccount>(config, 'OptionsAccount', authSettings);
    }

    /**
     *
     * @summary List account changing history
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     * @param opts.type Changing Type: - dnw: Deposit &amp; Withdraw - prem: Trading premium - fee: Trading fee - refr: Referrer rebate - set: settlement PNL
     */
    public async listOptionsAccountBook(opts: {
        limit?: number;
        offset?: number;
        from?: number;
        to?: number;
        type?: 'dnw' | 'prem' | 'fee' | 'refr' | 'set';
    }): Promise<{ response: AxiosResponse; body: Array<OptionsAccountBook> }> {
        const localVarPath = this.client.basePath + '/options/account_book';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(
                opts.type,
                "'dnw' | 'prem' | 'fee' | 'refr' | 'set'",
            );
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsAccountBook>>(config, 'Array<OptionsAccountBook>', authSettings);
    }

    /**
     *
     * @summary List user\'s positions of specified underlying
     * @param opts Optional parameters
     * @param opts.underlying Underlying
     */
    public async listOptionsPositions(opts: {
        underlying?: string;
    }): Promise<{ response: AxiosResponse; body: Array<OptionsPosition> }> {
        const localVarPath = this.client.basePath + '/options/positions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.underlying !== undefined) {
            localVarQueryParameters['underlying'] = ObjectSerializer.serialize(opts.underlying, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsPosition>>(config, 'Array<OptionsPosition>', authSettings);
    }

    /**
     *
     * @summary Get specified contract position
     * @param contract
     */
    public async getOptionsPosition(contract: string): Promise<{ response: AxiosResponse; body: OptionsPosition }> {
        const localVarPath =
            this.client.basePath +
            '/options/positions/{contract}'.replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getOptionsPosition.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsPosition>(config, 'OptionsPosition', authSettings);
    }

    /**
     *
     * @summary List user\'s liquidation history of specified underlying
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param opts Optional parameters
     * @param opts.contract Options contract name
     */
    public async listOptionsPositionClose(
        underlying: string,
        opts: { contract?: string },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsPositionClose> }> {
        const localVarPath = this.client.basePath + '/options/position_close';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error(
                'Required parameter underlying was null or undefined when calling listOptionsPositionClose.',
            );
        }

        opts = opts || {};
        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsPositionClose>>(config, 'Array<OptionsPositionClose>', authSettings);
    }

    /**
     *
     * @summary List options orders
     * @param status Only list the orders with this status
     * @param opts Optional parameters
     * @param opts.contract Options contract name
     * @param opts.underlying Underlying
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     */
    public async listOptionsOrders(
        status: 'open' | 'finished',
        opts: { contract?: string; underlying?: string; limit?: number; offset?: number; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsOrder> }> {
        const localVarPath = this.client.basePath + '/options/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling listOptionsOrders.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.underlying !== undefined) {
            localVarQueryParameters['underlying'] = ObjectSerializer.serialize(opts.underlying, 'string');
        }

        localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'open' | 'finished'");

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsOrder>>(config, 'Array<OptionsOrder>', authSettings);
    }

    /**
     *
     * @summary Create an options order
     * @param optionsOrder
     */
    public async createOptionsOrder(
        optionsOrder: OptionsOrder,
    ): Promise<{ response: AxiosResponse; body: OptionsOrder }> {
        const localVarPath = this.client.basePath + '/options/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'optionsOrder' is not null or undefined
        if (optionsOrder === null || optionsOrder === undefined) {
            throw new Error('Required parameter optionsOrder was null or undefined when calling createOptionsOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(optionsOrder, 'OptionsOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsOrder>(config, 'OptionsOrder', authSettings);
    }

    /**
     *
     * @summary Cancel all `open` orders matched
     * @param opts Optional parameters
     * @param opts.contract Options contract name
     * @param opts.underlying Underlying
     * @param opts.side All bids or asks. Both included if not specified
     */
    public async cancelOptionsOrders(opts: {
        contract?: string;
        underlying?: string;
        side?: 'ask' | 'bid';
    }): Promise<{ response: AxiosResponse; body: Array<OptionsOrder> }> {
        const localVarPath = this.client.basePath + '/options/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.underlying !== undefined) {
            localVarQueryParameters['underlying'] = ObjectSerializer.serialize(opts.underlying, 'string');
        }

        if (opts.side !== undefined) {
            localVarQueryParameters['side'] = ObjectSerializer.serialize(opts.side, "'ask' | 'bid'");
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsOrder>>(config, 'Array<OptionsOrder>', authSettings);
    }

    /**
     *
     * @summary Get a single order
     * @param orderId Order ID returned on successful order creation
     */
    public async getOptionsOrder(orderId: number): Promise<{ response: AxiosResponse; body: OptionsOrder }> {
        const localVarPath =
            this.client.basePath +
            '/options/orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOptionsOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsOrder>(config, 'OptionsOrder', authSettings);
    }

    /**
     *
     * @summary Cancel a single order
     * @param orderId Order ID returned on successful order creation
     */
    public async cancelOptionsOrder(orderId: number): Promise<{ response: AxiosResponse; body: OptionsOrder }> {
        const localVarPath =
            this.client.basePath +
            '/options/orders/{order_id}'.replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelOptionsOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsOrder>(config, 'OptionsOrder', authSettings);
    }

    /**
     * Option order heartbeat detection, when the `timeout` time set by the user is reached, if the existing countdown is not canceled or a new countdown is set, the related `option pending order` will be automatically canceled.  This interface can be called repeatedly to set a new countdown or cancel the countdown.  Usage example: Repeat this interface at intervals of 30 seconds, with each countdown `timeout` set to 30 (seconds).  If this interface is not called again within 30 seconds, all pending orders on the `underlying` `contract` you specified will be automatically cancelled. If `underlying` `contract` is not specified, all pending orders of the user will be automatically cancelled  If `timeout` is set to 0 within 30 seconds, the countdown timer will expire and the automatic order cancellation function will be cancelled.
     * @summary Countdown cancel orders
     * @param countdownCancelAllOptionsTask
     */
    public async countdownCancelAllOptions(
        countdownCancelAllOptionsTask: CountdownCancelAllOptionsTask,
    ): Promise<{ response: AxiosResponse; body: TriggerTime }> {
        const localVarPath = this.client.basePath + '/options/countdown_cancel_all';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'countdownCancelAllOptionsTask' is not null or undefined
        if (countdownCancelAllOptionsTask === null || countdownCancelAllOptionsTask === undefined) {
            throw new Error(
                'Required parameter countdownCancelAllOptionsTask was null or undefined when calling countdownCancelAllOptions.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(countdownCancelAllOptionsTask, 'CountdownCancelAllOptionsTask'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerTime>(config, 'TriggerTime', authSettings);
    }

    /**
     *
     * @summary List personal trading history
     * @param underlying Underlying (Obtained by listing underlying endpoint)
     * @param opts Optional parameters
     * @param opts.contract Options contract name
     * @param opts.limit Maximum number of records to be returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp
     * @param opts.to End timestamp
     */
    public async listMyOptionsTrades(
        underlying: string,
        opts: { contract?: string; limit?: number; offset?: number; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<OptionsMyTrade> }> {
        const localVarPath = this.client.basePath + '/options/my_trades';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'underlying' is not null or undefined
        if (underlying === null || underlying === undefined) {
            throw new Error('Required parameter underlying was null or undefined when calling listMyOptionsTrades.');
        }

        opts = opts || {};
        localVarQueryParameters['underlying'] = ObjectSerializer.serialize(underlying, 'string');

        if (opts.contract !== undefined) {
            localVarQueryParameters['contract'] = ObjectSerializer.serialize(opts.contract, 'string');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsMyTrade>>(config, 'Array<OptionsMyTrade>', authSettings);
    }

    /**
     *
     * @summary MMP Query
     * @param opts Optional parameters
     * @param opts.underlying Underlying
     */
    public async getOptionsMMP(opts: {
        underlying?: string;
    }): Promise<{ response: AxiosResponse; body: Array<OptionsMMP> }> {
        const localVarPath = this.client.basePath + '/options/mmp';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.underlying !== undefined) {
            localVarQueryParameters['underlying'] = ObjectSerializer.serialize(opts.underlying, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<OptionsMMP>>(config, 'Array<OptionsMMP>', authSettings);
    }

    /**
     *
     * @summary MMP Settings
     * @param optionsMMP
     */
    public async setOptionsMMP(optionsMMP: OptionsMMP): Promise<{ response: AxiosResponse; body: OptionsMMP }> {
        const localVarPath = this.client.basePath + '/options/mmp';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'optionsMMP' is not null or undefined
        if (optionsMMP === null || optionsMMP === undefined) {
            throw new Error('Required parameter optionsMMP was null or undefined when calling setOptionsMMP.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(optionsMMP, 'OptionsMMP'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsMMP>(config, 'OptionsMMP', authSettings);
    }

    /**
     *
     * @summary MMP Reset
     * @param optionsMMPReset
     */
    public async resetOptionsMMP(
        optionsMMPReset: OptionsMMPReset,
    ): Promise<{ response: AxiosResponse; body: OptionsMMP }> {
        const localVarPath = this.client.basePath + '/options/mmp/reset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'optionsMMPReset' is not null or undefined
        if (optionsMMPReset === null || optionsMMPReset === undefined) {
            throw new Error('Required parameter optionsMMPReset was null or undefined when calling resetOptionsMMP.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(optionsMMPReset, 'OptionsMMPReset'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<OptionsMMP>(config, 'OptionsMMP', authSettings);
    }
}
